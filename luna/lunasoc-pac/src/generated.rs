#![doc = "Peripheral access API for SOC microcontrollers (generated using svd2rust v0.28.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.28.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
use core::marker::PhantomData;
use core::ops::Deref;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + Default
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " Mask for bits of width 1"]
        fn one() -> Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                #[inline(always)]
                fn one() -> Self {
                    1
                }
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also be `modify`'ed."]
    pub trait Readable: RegisterSpec {
        #[doc = " Result from a call to `read` and argument to `modify`."]
        type Reader: From<R<Self>> + core::ops::Deref<Target = R<Self>>;
    }
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also be `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Writer type argument to `write`, et al."]
        type Writer: From<W<Self>> + core::ops::DerefMut<Target = W<Self>>;
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> REG::Reader {
            REG::Reader::from(R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            })
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut REG::Writer) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut REG::Writer::from(W {
                    bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                }))
                .bits,
            );
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F)
        where
            F: FnOnce(&mut REG::Writer) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut REG::Writer::from(W {
                    bits: REG::Ux::default(),
                    _reg: marker::PhantomData,
                }))
                .bits,
            );
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F)
        where
            for<'w> F: FnOnce(&REG::Reader, &'w mut REG::Writer) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            self.register.set(
                f(
                    &REG::Reader::from(R {
                        bits,
                        _reg: marker::PhantomData,
                    }),
                    &mut REG::Writer::from(W {
                        bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                            | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                        _reg: marker::PhantomData,
                    }),
                )
                .bits,
            );
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub struct R<REG: RegisterSpec + ?Sized> {
        pub(crate) bits: REG::Ux,
        _reg: marker::PhantomData<REG>,
    }
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub struct W<REG: RegisterSpec + ?Sized> {
        #[doc = "Writable bits"]
        pub(crate) bits: REG::Ux,
        _reg: marker::PhantomData<REG>,
    }
    impl<REG: RegisterSpec> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Read datasheet or reference manual to find what values are allowed to pass."]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc(hidden)]
    pub struct FieldReaderRaw<U, T> {
        pub(crate) bits: U,
        _reg: marker::PhantomData<T>,
    }
    impl<U, FI> FieldReaderRaw<U, FI>
    where
        U: Copy,
    {
        #[doc = " Creates a new instance of the reader."]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(bits: U) -> Self {
            Self {
                bits,
                _reg: marker::PhantomData,
            }
        }
    }
    #[doc(hidden)]
    pub struct BitReaderRaw<T> {
        pub(crate) bits: bool,
        _reg: marker::PhantomData<T>,
    }
    impl<FI> BitReaderRaw<FI> {
        #[doc = " Creates a new instance of the reader."]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(bits: bool) -> Self {
            Self {
                bits,
                _reg: marker::PhantomData,
            }
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<U, FI> = FieldReaderRaw<U, FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI> = BitReaderRaw<FI>;
    impl<U, FI> FieldReader<U, FI>
    where
        U: Copy,
    {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub fn bits(&self) -> U {
            self.bits
        }
    }
    impl<U, FI> PartialEq<FI> for FieldReader<U, FI>
    where
        U: PartialEq,
        FI: Copy,
        U: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&U::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    #[doc(hidden)]
    pub struct Safe;
    #[doc(hidden)]
    pub struct Unsafe;
    #[doc(hidden)]
    pub struct FieldWriterRaw<'a, U, REG, N, FI, Safety, const WI: u8, const O: u8>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        N: From<FI>,
    {
        pub(crate) w: &'a mut REG::Writer,
        _field: marker::PhantomData<(N, FI, Safety)>,
    }
    impl<'a, U, REG, N, FI, Safety, const WI: u8, const O: u8>
        FieldWriterRaw<'a, U, REG, N, FI, Safety, WI, O>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        N: From<FI>,
    {
        #[doc = " Creates a new instance of the writer"]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(w: &'a mut REG::Writer) -> Self {
            Self {
                w,
                _field: marker::PhantomData,
            }
        }
    }
    #[doc(hidden)]
    pub struct BitWriterRaw<'a, U, REG, FI, M, const O: u8>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        bool: From<FI>,
    {
        pub(crate) w: &'a mut REG::Writer,
        _field: marker::PhantomData<(FI, M)>,
    }
    impl<'a, U, REG, FI, M, const O: u8> BitWriterRaw<'a, U, REG, FI, M, O>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        bool: From<FI>,
    {
        #[doc = " Creates a new instance of the writer"]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(w: &'a mut REG::Writer) -> Self {
            Self {
                w,
                _field: marker::PhantomData,
            }
        }
    }
    #[doc = " Write field Proxy with unsafe `bits`"]
    pub type FieldWriter<'a, U, REG, N, FI, const WI: u8, const O: u8> =
        FieldWriterRaw<'a, U, REG, N, FI, Unsafe, WI, O>;
    #[doc = " Write field Proxy with safe `bits`"]
    pub type FieldWriterSafe<'a, U, REG, N, FI, const WI: u8, const O: u8> =
        FieldWriterRaw<'a, U, REG, N, FI, Safe, WI, O>;
    impl<'a, U, REG, N, FI, const WI: u8, const OF: u8> FieldWriter<'a, U, REG, N, FI, WI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        N: From<FI>,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
    }
    impl<'a, U, REG, N, FI, const WI: u8, const OF: u8> FieldWriterSafe<'a, U, REG, N, FI, WI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        N: From<FI>,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, U, REG, FI, const O: u8> = BitWriterRaw<'a, U, REG, FI, $mwv, O>;
            impl<'a, U, REG, FI, const OF: u8> $writer<'a, U, REG, FI, OF>
            where
                REG: Writable + RegisterSpec<Ux = U>,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
            }
        };
    }
    macro_rules! impl_bit_proxy {
        ($ writer : ident) => {
            impl<'a, U, REG, FI, const OF: u8> $writer<'a, U, REG, FI, OF>
            where
                REG: Writable + RegisterSpec<Ux = U>,
                U: RawReg,
                bool: From<FI>,
            {
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut REG::Writer {
                    self.w.bits &= !(U::one() << OF);
                    self.w.bits |= (U::from(value) & U::one()) << OF;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut REG::Writer {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, U, REG, N, FI, const WI: u8, const OF: u8> FieldWriter<'a, U, REG, N, FI, WI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg + From<N>,
        N: From<FI>,
    {
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: N) -> &'a mut REG::Writer {
            self.w.bits &= !(U::mask::<WI>() << OF);
            self.w.bits |= (U::from(value) & U::mask::<WI>()) << OF;
            self.w
        }
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut REG::Writer {
            unsafe { self.bits(N::from(variant)) }
        }
    }
    impl<'a, U, REG, N, FI, const WI: u8, const OF: u8> FieldWriterSafe<'a, U, REG, N, FI, WI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg + From<N>,
        N: From<FI>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn bits(self, value: N) -> &'a mut REG::Writer {
            self.w.bits &= !(U::mask::<WI>() << OF);
            self.w.bits |= (U::from(value) & U::mask::<WI>()) << OF;
            self.w
        }
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut REG::Writer {
            self.bits(N::from(variant))
        }
    }
    impl_bit_proxy!(BitWriter);
    impl_bit_proxy!(BitWriter1S);
    impl_bit_proxy!(BitWriter0C);
    impl_bit_proxy!(BitWriter1C);
    impl_bit_proxy!(BitWriter0S);
    impl_bit_proxy!(BitWriter1T);
    impl_bit_proxy!(BitWriter0T);
    impl<'a, U, REG, FI, const OF: u8> BitWriter<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut REG::Writer {
            self.w.bits |= U::one() << OF;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut REG::Writer {
            self.w.bits &= !(U::one() << OF);
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter1S<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut REG::Writer {
            self.w.bits |= U::one() << OF;
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter0C<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut REG::Writer {
            self.w.bits &= !(U::one() << OF);
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter1C<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut REG::Writer {
            self.w.bits |= U::one() << OF;
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter0S<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut REG::Writer {
            self.w.bits &= !(U::one() << OF);
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter1T<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut REG::Writer {
            self.w.bits |= U::one() << OF;
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter0T<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut REG::Writer {
            self.w.bits &= !(U::one() << OF);
            self.w
        }
    }
    #[doc = " Access an array of `COUNT` items of type `T` with the items `STRIDE` bytes"]
    #[doc = " apart.  This is a zero-sized-type.  No objects of this type are ever"]
    #[doc = " actually created, it is only a convenience for wrapping pointer arithmetic."]
    #[doc = ""]
    #[doc = " There is no safe way to produce items of this type.  Unsafe code can produce"]
    #[doc = " references by pointer casting.  It is up to the unsafe code doing that, to"]
    #[doc = " ensure that the memory really is backed by appropriate content."]
    #[doc = ""]
    #[doc = " Typically, this is used for accessing hardware registers."]
    pub struct ArrayProxy<T, const COUNT: usize, const STRIDE: usize> {
        #[doc = " As well as providing a PhantomData, this field is non-public, and"]
        #[doc = " therefore ensures that code outside of this module can never create"]
        #[doc = " an ArrayProxy."]
        _array: marker::PhantomData<T>,
    }
    #[allow(clippy::len_without_is_empty)]
    impl<T, const C: usize, const S: usize> ArrayProxy<T, C, S> {
        #[doc = " Get a reference from an [ArrayProxy]
with no bounds checking."]
        pub unsafe fn get_ref(&self, index: usize) -> &T {
            let base = self as *const Self as usize;
            let address = base + S * index;
            &*(address as *const T)
        }
        #[doc = " Get a reference from an [ArrayProxy], or return `None` if the index"]
        #[doc = " is out of bounds."]
        pub fn get(&self, index: usize) -> Option<&T> {
            if index < C {
                Some(unsafe { self.get_ref(index) })
            } else {
                None
            }
        }
        #[doc = " Return the number of items."]
        pub fn len(&self) -> usize {
            C
        }
    }
    impl<T, const C: usize, const S: usize> core::ops::Index<usize> for ArrayProxy<T, C, S> {
        type Output = T;
        fn index(&self, index: usize) -> &T {
            #[allow(clippy::no_effect)]
            [(); C][index];
            unsafe { self.get_ref(index) }
        }
    }
}
#[cfg(feature = "rt")]
extern "C" {
    fn TIMER();
    fn UART();
    fn USB0();
    fn USB0_SETUP();
    fn USB0_EP0_IN();
    fn USB0_EP0_OUT();
}
#[doc(hidden)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 6] = [
    Vector { _handler: TIMER },
    Vector { _handler: UART },
    Vector { _handler: USB0 },
    Vector {
        _handler: USB0_SETUP,
    },
    Vector {
        _handler: USB0_EP0_IN,
    },
    Vector {
        _handler: USB0_EP0_OUT,
    },
];
#[doc(hidden)]
pub mod interrupt {
    #[doc = r"Enumeration of all the interrupts."]
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        #[doc = "0 - timer"]
        TIMER = 0,
        #[doc = "1 - uart"]
        UART = 1,
        #[doc = "2 - usb0"]
        USB0 = 2,
        #[doc = "3 - usb0_setup"]
        USB0_SETUP = 3,
        #[doc = "4 - usb0_ep0_in"]
        USB0_EP0_IN = 4,
        #[doc = "5 - usb0_ep0_out"]
        USB0_EP0_OUT = 5,
    }
    #[doc = r" TryFromInterruptError"]
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        #[doc = r" Attempt to convert a given value into an `Interrupt`"]
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                0 => Ok(Interrupt::TIMER),
                1 => Ok(Interrupt::UART),
                2 => Ok(Interrupt::USB0),
                3 => Ok(Interrupt::USB0_SETUP),
                4 => Ok(Interrupt::USB0_EP0_IN),
                5 => Ok(Interrupt::USB0_EP0_OUT),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    #[doc = r" Assigns a handler to an interrupt"]
    #[doc = r""]
    #[doc = r" This macro takes two arguments: the name of an interrupt and the path to the"]
    #[doc = r" function that will be used as the handler of that interrupt. That function"]
    #[doc = r" must have signature `fn()`."]
    #[doc = r""]
    #[doc = r" Optionally, a third argument may be used to declare interrupt local data."]
    #[doc = r" The handler will have exclusive access to these *local* variables on each"]
    #[doc = r" invocation. If the third argument is used then the signature of the handler"]
    #[doc = r" function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument"]
    #[doc = r" passed to the macro."]
    #[doc = r""]
    #[doc = r" # Example"]
    #[doc = r""]
    #[doc = r" ``` ignore"]
    #[doc = r" interrupt!(TIM2, periodic);"]
    #[doc = r""]
    #[doc = r" fn periodic() {"]
    #[doc = r#"     print!(".");"#]
    #[doc = r" }"]
    #[doc = r""]
    #[doc = r" interrupt!(TIM3, tick, locals: {"]
    #[doc = r"     tick: bool = false;"]
    #[doc = r" });"]
    #[doc = r""]
    #[doc = r" fn tick(locals: &mut TIM3::Locals) {"]
    #[doc = r"     locals.tick = !locals.tick;"]
    #[doc = r""]
    #[doc = r"     if locals.tick {"]
    #[doc = r#"         println!("Tick");"#]
    #[doc = r"     } else {"]
    #[doc = r#"         println!("Tock");"#]
    #[doc = r"     }"]
    #[doc = r" }"]
    #[doc = r" ```"]
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
#[doc = "TIMER"]
pub struct TIMER {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER {}
impl TIMER {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0x8000_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER").finish()
    }
}
#[doc = "TIMER"]
pub mod timer {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - timer reload register"]
        pub reload: RELOAD,
        #[doc = "0x04 - timer en register"]
        pub en: EN,
        #[doc = "0x08 - timer ctr register"]
        pub ctr: CTR,
        _reserved3: [u8; 0x04],
        #[doc = "0x10 - timer ev_status register"]
        pub ev_status: EV_STATUS,
        #[doc = "0x14 - timer ev_pending register"]
        pub ev_pending: EV_PENDING,
        #[doc = "0x18 - timer ev_enable register"]
        pub ev_enable: EV_ENABLE,
    }
    #[doc = "reload (rw) register accessor: an alias for `Reg<RELOAD_SPEC>`"]
    pub type RELOAD = crate::Reg<reload::RELOAD_SPEC>;
    #[doc = "timer reload register"]
    pub mod reload {
        #[doc = "Register `reload` reader"]
        pub struct R(crate::R<RELOAD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RELOAD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RELOAD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RELOAD_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `reload` writer"]
        pub struct W(crate::W<RELOAD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RELOAD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RELOAD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RELOAD_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `reload` reader - timer reload register field"]
        pub type RELOAD_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `reload` writer - timer reload register field"]
        pub type RELOAD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, RELOAD_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - timer reload register field"]
            #[inline(always)]
            pub fn reload(&self) -> RELOAD_R {
                RELOAD_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - timer reload register field"]
            #[inline(always)]
            #[must_use]
            pub fn reload(&mut self) -> RELOAD_W<0> {
                RELOAD_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "timer reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reload](index.html) module"]
        pub struct RELOAD_SPEC;
        impl crate::RegisterSpec for RELOAD_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [reload::R](R) reader structure"]
        impl crate::Readable for RELOAD_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [reload::W](W) writer structure"]
        impl crate::Writable for RELOAD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets reload to value 0"]
        impl crate::Resettable for RELOAD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "en (rw) register accessor: an alias for `Reg<EN_SPEC>`"]
    pub type EN = crate::Reg<en::EN_SPEC>;
    #[doc = "timer en register"]
    pub mod en {
        #[doc = "Register `en` reader"]
        pub struct R(crate::R<EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EN_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `en` writer"]
        pub struct W(crate::W<EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EN_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `en` reader - timer en register field"]
        pub type EN_R = crate::BitReader<bool>;
        #[doc = "Field `en` writer - timer en register field"]
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, EN_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - timer en register field"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - timer en register field"]
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "timer en register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [en](index.html) module"]
        pub struct EN_SPEC;
        impl crate::RegisterSpec for EN_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [en::R](R) reader structure"]
        impl crate::Readable for EN_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [en::W](W) writer structure"]
        impl crate::Writable for EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets en to value 0"]
        impl crate::Resettable for EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ctr (rw) register accessor: an alias for `Reg<CTR_SPEC>`"]
    pub type CTR = crate::Reg<ctr::CTR_SPEC>;
    #[doc = "timer ctr register"]
    pub mod ctr {
        #[doc = "Register `ctr` reader"]
        pub struct R(crate::R<CTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ctr` writer"]
        pub struct W(crate::W<CTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `ctr` reader - timer ctr register field"]
        pub type CTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `ctr` writer - timer ctr register field"]
        pub type CTR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTR_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - timer ctr register field"]
            #[inline(always)]
            pub fn ctr(&self) -> CTR_R {
                CTR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - timer ctr register field"]
            #[inline(always)]
            #[must_use]
            pub fn ctr(&mut self) -> CTR_W<0> {
                CTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "timer ctr register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctr](index.html) module"]
        pub struct CTR_SPEC;
        impl crate::RegisterSpec for CTR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ctr::R](R) reader structure"]
        impl crate::Readable for CTR_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ctr::W](W) writer structure"]
        impl crate::Writable for CTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ctr to value 0"]
        impl crate::Resettable for CTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_status (r) register accessor: an alias for `Reg<EV_STATUS_SPEC>`"]
    pub type EV_STATUS = crate::Reg<ev_status::EV_STATUS_SPEC>;
    #[doc = "timer ev_status register"]
    pub mod ev_status {
        #[doc = "Register `ev_status` reader"]
        pub struct R(crate::R<EV_STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `status` reader - timer status register field"]
        pub type STATUS_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - timer status register field"]
            #[inline(always)]
            pub fn status(&self) -> STATUS_R {
                STATUS_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "timer ev_status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_status](index.html) module"]
        pub struct EV_STATUS_SPEC;
        impl crate::RegisterSpec for EV_STATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_status::R](R) reader structure"]
        impl crate::Readable for EV_STATUS_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets ev_status to value 0"]
        impl crate::Resettable for EV_STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_pending (rw) register accessor: an alias for `Reg<EV_PENDING_SPEC>`"]
    pub type EV_PENDING = crate::Reg<ev_pending::EV_PENDING_SPEC>;
    #[doc = "timer ev_pending register"]
    pub mod ev_pending {
        #[doc = "Register `ev_pending` reader"]
        pub struct R(crate::R<EV_PENDING_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_PENDING_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_PENDING_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_PENDING_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ev_pending` writer"]
        pub struct W(crate::W<EV_PENDING_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EV_PENDING_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EV_PENDING_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EV_PENDING_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `pending` reader - timer pending register field"]
        pub type PENDING_R = crate::BitReader<bool>;
        #[doc = "Field `pending` writer - timer pending register field"]
        pub type PENDING_W<'a, const O: u8> = crate::BitWriter<'a, u32, EV_PENDING_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - timer pending register field"]
            #[inline(always)]
            pub fn pending(&self) -> PENDING_R {
                PENDING_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - timer pending register field"]
            #[inline(always)]
            #[must_use]
            pub fn pending(&mut self) -> PENDING_W<0> {
                PENDING_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "timer ev_pending register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_pending](index.html) module"]
        pub struct EV_PENDING_SPEC;
        impl crate::RegisterSpec for EV_PENDING_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_pending::R](R) reader structure"]
        impl crate::Readable for EV_PENDING_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ev_pending::W](W) writer structure"]
        impl crate::Writable for EV_PENDING_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ev_pending to value 0"]
        impl crate::Resettable for EV_PENDING_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_enable (rw) register accessor: an alias for `Reg<EV_ENABLE_SPEC>`"]
    pub type EV_ENABLE = crate::Reg<ev_enable::EV_ENABLE_SPEC>;
    #[doc = "timer ev_enable register"]
    pub mod ev_enable {
        #[doc = "Register `ev_enable` reader"]
        pub struct R(crate::R<EV_ENABLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_ENABLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_ENABLE_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ev_enable` writer"]
        pub struct W(crate::W<EV_ENABLE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EV_ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EV_ENABLE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EV_ENABLE_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `enable` reader - timer enable register field"]
        pub type ENABLE_R = crate::BitReader<bool>;
        #[doc = "Field `enable` writer - timer enable register field"]
        pub type ENABLE_W<'a, const O: u8> = crate::BitWriter<'a, u32, EV_ENABLE_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - timer enable register field"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - timer enable register field"]
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<0> {
                ENABLE_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "timer ev_enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_enable](index.html) module"]
        pub struct EV_ENABLE_SPEC;
        impl crate::RegisterSpec for EV_ENABLE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_enable::R](R) reader structure"]
        impl crate::Readable for EV_ENABLE_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ev_enable::W](W) writer structure"]
        impl crate::Writable for EV_ENABLE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ev_enable to value 0"]
        impl crate::Resettable for EV_ENABLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "UART"]
pub struct UART {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART {}
impl UART {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0x8000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART").finish()
    }
}
#[doc = "UART"]
pub mod uart {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - uart divisor register"]
        pub divisor: DIVISOR,
        #[doc = "0x04 - uart rx_data register"]
        pub rx_data: RX_DATA,
        #[doc = "0x08 - uart rx_rdy register"]
        pub rx_rdy: RX_RDY,
        #[doc = "0x0c - uart rx_err register"]
        pub rx_err: RX_ERR,
        #[doc = "0x10 - uart tx_data register"]
        pub tx_data: TX_DATA,
        #[doc = "0x14 - uart tx_rdy register"]
        pub tx_rdy: TX_RDY,
        _reserved6: [u8; 0x08],
        #[doc = "0x20 - uart ev_status register"]
        pub ev_status: EV_STATUS,
        #[doc = "0x24 - uart ev_pending register"]
        pub ev_pending: EV_PENDING,
        #[doc = "0x28 - uart ev_enable register"]
        pub ev_enable: EV_ENABLE,
    }
    #[doc = "divisor (rw) register accessor: an alias for `Reg<DIVISOR_SPEC>`"]
    pub type DIVISOR = crate::Reg<divisor::DIVISOR_SPEC>;
    #[doc = "uart divisor register"]
    pub mod divisor {
        #[doc = "Register `divisor` reader"]
        pub struct R(crate::R<DIVISOR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIVISOR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DIVISOR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DIVISOR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `divisor` writer"]
        pub struct W(crate::W<DIVISOR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DIVISOR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DIVISOR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DIVISOR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `divisor` reader - uart divisor register field"]
        pub type DIVISOR_R = crate::FieldReader<u16, u16>;
        #[doc = "Field `divisor` writer - uart divisor register field"]
        pub type DIVISOR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, DIVISOR_SPEC, u16, u16, 10, O>;
        impl R {
            #[doc = "Bits 0:9 - uart divisor register field"]
            #[inline(always)]
            pub fn divisor(&self) -> DIVISOR_R {
                DIVISOR_R::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:9 - uart divisor register field"]
            #[inline(always)]
            #[must_use]
            pub fn divisor(&mut self) -> DIVISOR_W<0> {
                DIVISOR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "uart divisor register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [divisor](index.html) module"]
        pub struct DIVISOR_SPEC;
        impl crate::RegisterSpec for DIVISOR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [divisor::R](R) reader structure"]
        impl crate::Readable for DIVISOR_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [divisor::W](W) writer structure"]
        impl crate::Writable for DIVISOR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets divisor to value 0"]
        impl crate::Resettable for DIVISOR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "rx_data (r) register accessor: an alias for `Reg<RX_DATA_SPEC>`"]
    pub type RX_DATA = crate::Reg<rx_data::RX_DATA_SPEC>;
    #[doc = "uart rx_data register"]
    pub mod rx_data {
        #[doc = "Register `rx_data` reader"]
        pub struct R(crate::R<RX_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RX_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RX_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RX_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `rx_data` reader - uart rx_data register field"]
        pub type RX_DATA_R = crate::FieldReader<u8, u8>;
        impl R {
            #[doc = "Bits 0:7 - uart rx_data register field"]
            #[inline(always)]
            pub fn rx_data(&self) -> RX_DATA_R {
                RX_DATA_R::new((self.bits & 0xff) as u8)
            }
        }
        #[doc = "uart rx_data register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rx_data](index.html) module"]
        pub struct RX_DATA_SPEC;
        impl crate::RegisterSpec for RX_DATA_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [rx_data::R](R) reader structure"]
        impl crate::Readable for RX_DATA_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets rx_data to value 0"]
        impl crate::Resettable for RX_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "rx_rdy (r) register accessor: an alias for `Reg<RX_RDY_SPEC>`"]
    pub type RX_RDY = crate::Reg<rx_rdy::RX_RDY_SPEC>;
    #[doc = "uart rx_rdy register"]
    pub mod rx_rdy {
        #[doc = "Register `rx_rdy` reader"]
        pub struct R(crate::R<RX_RDY_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RX_RDY_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RX_RDY_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RX_RDY_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `rx_rdy` reader - uart rx_rdy register field"]
        pub type RX_RDY_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - uart rx_rdy register field"]
            #[inline(always)]
            pub fn rx_rdy(&self) -> RX_RDY_R {
                RX_RDY_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "uart rx_rdy register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rx_rdy](index.html) module"]
        pub struct RX_RDY_SPEC;
        impl crate::RegisterSpec for RX_RDY_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [rx_rdy::R](R) reader structure"]
        impl crate::Readable for RX_RDY_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets rx_rdy to value 0"]
        impl crate::Resettable for RX_RDY_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "rx_err (r) register accessor: an alias for `Reg<RX_ERR_SPEC>`"]
    pub type RX_ERR = crate::Reg<rx_err::RX_ERR_SPEC>;
    #[doc = "uart rx_err register"]
    pub mod rx_err {
        #[doc = "Register `rx_err` reader"]
        pub struct R(crate::R<RX_ERR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RX_ERR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RX_ERR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RX_ERR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `rx_err` reader - uart rx_err register field"]
        pub type RX_ERR_R = crate::FieldReader<u8, u8>;
        impl R {
            #[doc = "Bits 0:2 - uart rx_err register field"]
            #[inline(always)]
            pub fn rx_err(&self) -> RX_ERR_R {
                RX_ERR_R::new((self.bits & 7) as u8)
            }
        }
        #[doc = "uart rx_err register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rx_err](index.html) module"]
        pub struct RX_ERR_SPEC;
        impl crate::RegisterSpec for RX_ERR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [rx_err::R](R) reader structure"]
        impl crate::Readable for RX_ERR_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets rx_err to value 0"]
        impl crate::Resettable for RX_ERR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "tx_data (w) register accessor: an alias for `Reg<TX_DATA_SPEC>`"]
    pub type TX_DATA = crate::Reg<tx_data::TX_DATA_SPEC>;
    #[doc = "uart tx_data register"]
    pub mod tx_data {
        #[doc = "Register `tx_data` writer"]
        pub struct W(crate::W<TX_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TX_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TX_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TX_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `tx_data` writer - uart tx_data register field"]
        pub type TX_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, TX_DATA_SPEC, u8, u8, 8, O>;
        impl W {
            #[doc = "Bits 0:7 - uart tx_data register field"]
            #[inline(always)]
            #[must_use]
            pub fn tx_data(&mut self) -> TX_DATA_W<0> {
                TX_DATA_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "uart tx_data register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tx_data](index.html) module"]
        pub struct TX_DATA_SPEC;
        impl crate::RegisterSpec for TX_DATA_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [tx_data::W](W) writer structure"]
        impl crate::Writable for TX_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets tx_data to value 0"]
        impl crate::Resettable for TX_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "tx_rdy (r) register accessor: an alias for `Reg<TX_RDY_SPEC>`"]
    pub type TX_RDY = crate::Reg<tx_rdy::TX_RDY_SPEC>;
    #[doc = "uart tx_rdy register"]
    pub mod tx_rdy {
        #[doc = "Register `tx_rdy` reader"]
        pub struct R(crate::R<TX_RDY_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TX_RDY_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TX_RDY_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TX_RDY_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `tx_rdy` reader - uart tx_rdy register field"]
        pub type TX_RDY_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - uart tx_rdy register field"]
            #[inline(always)]
            pub fn tx_rdy(&self) -> TX_RDY_R {
                TX_RDY_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "uart tx_rdy register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tx_rdy](index.html) module"]
        pub struct TX_RDY_SPEC;
        impl crate::RegisterSpec for TX_RDY_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [tx_rdy::R](R) reader structure"]
        impl crate::Readable for TX_RDY_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets tx_rdy to value 0"]
        impl crate::Resettable for TX_RDY_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_status (r) register accessor: an alias for `Reg<EV_STATUS_SPEC>`"]
    pub type EV_STATUS = crate::Reg<ev_status::EV_STATUS_SPEC>;
    #[doc = "uart ev_status register"]
    pub mod ev_status {
        #[doc = "Register `ev_status` reader"]
        pub struct R(crate::R<EV_STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `status` reader - uart status register field"]
        pub type STATUS_R = crate::FieldReader<u8, u8>;
        impl R {
            #[doc = "Bits 0:2 - uart status register field"]
            #[inline(always)]
            pub fn status(&self) -> STATUS_R {
                STATUS_R::new((self.bits & 7) as u8)
            }
        }
        #[doc = "uart ev_status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_status](index.html) module"]
        pub struct EV_STATUS_SPEC;
        impl crate::RegisterSpec for EV_STATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_status::R](R) reader structure"]
        impl crate::Readable for EV_STATUS_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets ev_status to value 0"]
        impl crate::Resettable for EV_STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_pending (rw) register accessor: an alias for `Reg<EV_PENDING_SPEC>`"]
    pub type EV_PENDING = crate::Reg<ev_pending::EV_PENDING_SPEC>;
    #[doc = "uart ev_pending register"]
    pub mod ev_pending {
        #[doc = "Register `ev_pending` reader"]
        pub struct R(crate::R<EV_PENDING_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_PENDING_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_PENDING_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_PENDING_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ev_pending` writer"]
        pub struct W(crate::W<EV_PENDING_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EV_PENDING_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EV_PENDING_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EV_PENDING_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `pending` reader - uart pending register field"]
        pub type PENDING_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `pending` writer - uart pending register field"]
        pub type PENDING_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, EV_PENDING_SPEC, u8, u8, 3, O>;
        impl R {
            #[doc = "Bits 0:2 - uart pending register field"]
            #[inline(always)]
            pub fn pending(&self) -> PENDING_R {
                PENDING_R::new((self.bits & 7) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - uart pending register field"]
            #[inline(always)]
            #[must_use]
            pub fn pending(&mut self) -> PENDING_W<0> {
                PENDING_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "uart ev_pending register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_pending](index.html) module"]
        pub struct EV_PENDING_SPEC;
        impl crate::RegisterSpec for EV_PENDING_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_pending::R](R) reader structure"]
        impl crate::Readable for EV_PENDING_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ev_pending::W](W) writer structure"]
        impl crate::Writable for EV_PENDING_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ev_pending to value 0"]
        impl crate::Resettable for EV_PENDING_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_enable (rw) register accessor: an alias for `Reg<EV_ENABLE_SPEC>`"]
    pub type EV_ENABLE = crate::Reg<ev_enable::EV_ENABLE_SPEC>;
    #[doc = "uart ev_enable register"]
    pub mod ev_enable {
        #[doc = "Register `ev_enable` reader"]
        pub struct R(crate::R<EV_ENABLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_ENABLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_ENABLE_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ev_enable` writer"]
        pub struct W(crate::W<EV_ENABLE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EV_ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EV_ENABLE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EV_ENABLE_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `enable` reader - uart enable register field"]
        pub type ENABLE_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `enable` writer - uart enable register field"]
        pub type ENABLE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, EV_ENABLE_SPEC, u8, u8, 3, O>;
        impl R {
            #[doc = "Bits 0:2 - uart enable register field"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 7) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - uart enable register field"]
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<0> {
                ENABLE_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "uart ev_enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_enable](index.html) module"]
        pub struct EV_ENABLE_SPEC;
        impl crate::RegisterSpec for EV_ENABLE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_enable::R](R) reader structure"]
        impl crate::Readable for EV_ENABLE_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ev_enable::W](W) writer structure"]
        impl crate::Writable for EV_ENABLE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ev_enable to value 0"]
        impl crate::Resettable for EV_ENABLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "USB0"]
pub struct USB0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB0 {}
impl USB0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0::RegisterBlock = 0x5000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USB0 {
    type Target = usb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB0").finish()
    }
}
#[doc = "USB0"]
pub mod usb0 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - usb0 connect register"]
        pub connect: CONNECT,
        #[doc = "0x04 - usb0 speed register"]
        pub speed: SPEED,
        _reserved2: [u8; 0x08],
        #[doc = "0x10 - usb0 ev_status register"]
        pub ev_status: EV_STATUS,
        #[doc = "0x14 - usb0 ev_pending register"]
        pub ev_pending: EV_PENDING,
        #[doc = "0x18 - usb0 ev_enable register"]
        pub ev_enable: EV_ENABLE,
    }
    #[doc = "connect (rw) register accessor: an alias for `Reg<CONNECT_SPEC>`"]
    pub type CONNECT = crate::Reg<connect::CONNECT_SPEC>;
    #[doc = "usb0 connect register"]
    pub mod connect {
        #[doc = "Register `connect` reader"]
        pub struct R(crate::R<CONNECT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CONNECT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CONNECT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CONNECT_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `connect` writer"]
        pub struct W(crate::W<CONNECT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CONNECT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CONNECT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CONNECT_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `connect` reader - Set this bit to '1' to allow the associated USB device to connect to a host."]
        pub type CONNECT_R = crate::BitReader<bool>;
        #[doc = "Field `connect` writer - Set this bit to '1' to allow the associated USB device to connect to a host."]
        pub type CONNECT_W<'a, const O: u8> = crate::BitWriter<'a, u32, CONNECT_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - Set this bit to '1' to allow the associated USB device to connect to a host."]
            #[inline(always)]
            pub fn connect(&self) -> CONNECT_R {
                CONNECT_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Set this bit to '1' to allow the associated USB device to connect to a host."]
            #[inline(always)]
            #[must_use]
            pub fn connect(&mut self) -> CONNECT_W<0> {
                CONNECT_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0 connect register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [connect](index.html) module"]
        pub struct CONNECT_SPEC;
        impl crate::RegisterSpec for CONNECT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [connect::R](R) reader structure"]
        impl crate::Readable for CONNECT_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [connect::W](W) writer structure"]
        impl crate::Writable for CONNECT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets connect to value 0"]
        impl crate::Resettable for CONNECT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "speed (r) register accessor: an alias for `Reg<SPEED_SPEC>`"]
    pub type SPEED = crate::Reg<speed::SPEED_SPEC>;
    #[doc = "usb0 speed register"]
    pub mod speed {
        #[doc = "Register `speed` reader"]
        pub struct R(crate::R<SPEED_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPEED_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPEED_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPEED_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `speed` reader - Indicates the current speed of the USB device. 0 indicates High; 1 => Full, 2 => Low, and 3 => SuperSpeed (incl SuperSpeed+)."]
        pub type SPEED_R = crate::FieldReader<u8, u8>;
        impl R {
            #[doc = "Bits 0:1 - Indicates the current speed of the USB device. 0 indicates High; 1 => Full, 2 => Low, and 3 => SuperSpeed (incl SuperSpeed+)."]
            #[inline(always)]
            pub fn speed(&self) -> SPEED_R {
                SPEED_R::new((self.bits & 3) as u8)
            }
        }
        #[doc = "usb0 speed register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [speed](index.html) module"]
        pub struct SPEED_SPEC;
        impl crate::RegisterSpec for SPEED_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [speed::R](R) reader structure"]
        impl crate::Readable for SPEED_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets speed to value 0"]
        impl crate::Resettable for SPEED_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_status (r) register accessor: an alias for `Reg<EV_STATUS_SPEC>`"]
    pub type EV_STATUS = crate::Reg<ev_status::EV_STATUS_SPEC>;
    #[doc = "usb0 ev_status register"]
    pub mod ev_status {
        #[doc = "Register `ev_status` reader"]
        pub struct R(crate::R<EV_STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `status` reader - usb0 status register field"]
        pub type STATUS_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - usb0 status register field"]
            #[inline(always)]
            pub fn status(&self) -> STATUS_R {
                STATUS_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "usb0 ev_status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_status](index.html) module"]
        pub struct EV_STATUS_SPEC;
        impl crate::RegisterSpec for EV_STATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_status::R](R) reader structure"]
        impl crate::Readable for EV_STATUS_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets ev_status to value 0"]
        impl crate::Resettable for EV_STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_pending (rw) register accessor: an alias for `Reg<EV_PENDING_SPEC>`"]
    pub type EV_PENDING = crate::Reg<ev_pending::EV_PENDING_SPEC>;
    #[doc = "usb0 ev_pending register"]
    pub mod ev_pending {
        #[doc = "Register `ev_pending` reader"]
        pub struct R(crate::R<EV_PENDING_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_PENDING_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_PENDING_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_PENDING_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ev_pending` writer"]
        pub struct W(crate::W<EV_PENDING_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EV_PENDING_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EV_PENDING_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EV_PENDING_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `pending` reader - usb0 pending register field"]
        pub type PENDING_R = crate::BitReader<bool>;
        #[doc = "Field `pending` writer - usb0 pending register field"]
        pub type PENDING_W<'a, const O: u8> = crate::BitWriter<'a, u32, EV_PENDING_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - usb0 pending register field"]
            #[inline(always)]
            pub fn pending(&self) -> PENDING_R {
                PENDING_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - usb0 pending register field"]
            #[inline(always)]
            #[must_use]
            pub fn pending(&mut self) -> PENDING_W<0> {
                PENDING_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0 ev_pending register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_pending](index.html) module"]
        pub struct EV_PENDING_SPEC;
        impl crate::RegisterSpec for EV_PENDING_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_pending::R](R) reader structure"]
        impl crate::Readable for EV_PENDING_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ev_pending::W](W) writer structure"]
        impl crate::Writable for EV_PENDING_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ev_pending to value 0"]
        impl crate::Resettable for EV_PENDING_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_enable (rw) register accessor: an alias for `Reg<EV_ENABLE_SPEC>`"]
    pub type EV_ENABLE = crate::Reg<ev_enable::EV_ENABLE_SPEC>;
    #[doc = "usb0 ev_enable register"]
    pub mod ev_enable {
        #[doc = "Register `ev_enable` reader"]
        pub struct R(crate::R<EV_ENABLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_ENABLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_ENABLE_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ev_enable` writer"]
        pub struct W(crate::W<EV_ENABLE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EV_ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EV_ENABLE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EV_ENABLE_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `enable` reader - usb0 enable register field"]
        pub type ENABLE_R = crate::BitReader<bool>;
        #[doc = "Field `enable` writer - usb0 enable register field"]
        pub type ENABLE_W<'a, const O: u8> = crate::BitWriter<'a, u32, EV_ENABLE_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - usb0 enable register field"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - usb0 enable register field"]
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<0> {
                ENABLE_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0 ev_enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_enable](index.html) module"]
        pub struct EV_ENABLE_SPEC;
        impl crate::RegisterSpec for EV_ENABLE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_enable::R](R) reader structure"]
        impl crate::Readable for EV_ENABLE_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ev_enable::W](W) writer structure"]
        impl crate::Writable for EV_ENABLE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ev_enable to value 0"]
        impl crate::Resettable for EV_ENABLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "USB0_SETUP"]
pub struct USB0_SETUP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB0_SETUP {}
impl USB0_SETUP {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_setup::RegisterBlock = 0x5000_0040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_setup::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USB0_SETUP {
    type Target = usb0_setup::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB0_SETUP {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB0_SETUP").finish()
    }
}
#[doc = "USB0_SETUP"]
pub mod usb0_setup {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - usb0_setup data register"]
        pub data: DATA,
        #[doc = "0x04 - usb0_setup reset register"]
        pub reset: RESET,
        #[doc = "0x08 - usb0_setup epno register"]
        pub epno: EPNO,
        #[doc = "0x0c - usb0_setup have register"]
        pub have: HAVE,
        #[doc = "0x10 - usb0_setup pend register"]
        pub pend: PEND,
        #[doc = "0x14 - usb0_setup address register"]
        pub address: ADDRESS,
        _reserved6: [u8; 0x08],
        #[doc = "0x20 - usb0_setup ev_status register"]
        pub ev_status: EV_STATUS,
        #[doc = "0x24 - usb0_setup ev_pending register"]
        pub ev_pending: EV_PENDING,
        #[doc = "0x28 - usb0_setup ev_enable register"]
        pub ev_enable: EV_ENABLE,
    }
    #[doc = "data (r) register accessor: an alias for `Reg<DATA_SPEC>`"]
    pub type DATA = crate::Reg<data::DATA_SPEC>;
    #[doc = "usb0_setup data register"]
    pub mod data {
        #[doc = "Register `data` reader"]
        pub struct R(crate::R<DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `data` reader - A FIFO that returns the bytes from the most recently captured SETUP packet. Reading a byte from this register advances the FIFO. The first eight bytes read from this conain the core SETUP packet."]
        pub type DATA_R = crate::FieldReader<u8, u8>;
        impl R {
            #[doc = "Bits 0:7 - A FIFO that returns the bytes from the most recently captured SETUP packet. Reading a byte from this register advances the FIFO. The first eight bytes read from this conain the core SETUP packet."]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xff) as u8)
            }
        }
        #[doc = "usb0_setup data register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
        pub struct DATA_SPEC;
        impl crate::RegisterSpec for DATA_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [data::R](R) reader structure"]
        impl crate::Readable for DATA_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets data to value 0"]
        impl crate::Resettable for DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "reset (w) register accessor: an alias for `Reg<RESET_SPEC>`"]
    pub type RESET = crate::Reg<reset::RESET_SPEC>;
    #[doc = "usb0_setup reset register"]
    pub mod reset {
        #[doc = "Register `reset` writer"]
        pub struct W(crate::W<RESET_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RESET_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RESET_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RESET_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `reset` writer - Local reset control for the SETUP handler; writing a '1' to this register clears the handler state."]
        pub type RESET_W<'a, const O: u8> = crate::BitWriter<'a, u32, RESET_SPEC, bool, O>;
        impl W {
            #[doc = "Bit 0 - Local reset control for the SETUP handler; writing a '1' to this register clears the handler state."]
            #[inline(always)]
            #[must_use]
            pub fn reset(&mut self) -> RESET_W<0> {
                RESET_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_setup reset register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reset](index.html) module"]
        pub struct RESET_SPEC;
        impl crate::RegisterSpec for RESET_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [reset::W](W) writer structure"]
        impl crate::Writable for RESET_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets reset to value 0"]
        impl crate::Resettable for RESET_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "epno (r) register accessor: an alias for `Reg<EPNO_SPEC>`"]
    pub type EPNO = crate::Reg<epno::EPNO_SPEC>;
    #[doc = "usb0_setup epno register"]
    pub mod epno {
        #[doc = "Register `epno` reader"]
        pub struct R(crate::R<EPNO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EPNO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EPNO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EPNO_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `epno` reader - The number of the endpoint associated with the current SETUP packet."]
        pub type EPNO_R = crate::FieldReader<u8, u8>;
        impl R {
            #[doc = "Bits 0:3 - The number of the endpoint associated with the current SETUP packet."]
            #[inline(always)]
            pub fn epno(&self) -> EPNO_R {
                EPNO_R::new((self.bits & 0x0f) as u8)
            }
        }
        #[doc = "usb0_setup epno register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [epno](index.html) module"]
        pub struct EPNO_SPEC;
        impl crate::RegisterSpec for EPNO_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [epno::R](R) reader structure"]
        impl crate::Readable for EPNO_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets epno to value 0"]
        impl crate::Resettable for EPNO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "have (r) register accessor: an alias for `Reg<HAVE_SPEC>`"]
    pub type HAVE = crate::Reg<have::HAVE_SPEC>;
    #[doc = "usb0_setup have register"]
    pub mod have {
        #[doc = "Register `have` reader"]
        pub struct R(crate::R<HAVE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<HAVE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<HAVE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<HAVE_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `have` reader - `1` iff data is available in the FIFO."]
        pub type HAVE_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - `1` iff data is available in the FIFO."]
            #[inline(always)]
            pub fn have(&self) -> HAVE_R {
                HAVE_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "usb0_setup have register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [have](index.html) module"]
        pub struct HAVE_SPEC;
        impl crate::RegisterSpec for HAVE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [have::R](R) reader structure"]
        impl crate::Readable for HAVE_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets have to value 0"]
        impl crate::Resettable for HAVE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "pend (r) register accessor: an alias for `Reg<PEND_SPEC>`"]
    pub type PEND = crate::Reg<pend::PEND_SPEC>;
    #[doc = "usb0_setup pend register"]
    pub mod pend {
        #[doc = "Register `pend` reader"]
        pub struct R(crate::R<PEND_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PEND_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PEND_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PEND_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `pend` reader - `1` iff an interrupt is pending"]
        pub type PEND_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - `1` iff an interrupt is pending"]
            #[inline(always)]
            pub fn pend(&self) -> PEND_R {
                PEND_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "usb0_setup pend register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pend](index.html) module"]
        pub struct PEND_SPEC;
        impl crate::RegisterSpec for PEND_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [pend::R](R) reader structure"]
        impl crate::Readable for PEND_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets pend to value 0"]
        impl crate::Resettable for PEND_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "address (rw) register accessor: an alias for `Reg<ADDRESS_SPEC>`"]
    pub type ADDRESS = crate::Reg<address::ADDRESS_SPEC>;
    #[doc = "usb0_setup address register"]
    pub mod address {
        #[doc = "Register `address` reader"]
        pub struct R(crate::R<ADDRESS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADDRESS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADDRESS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADDRESS_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `address` writer"]
        pub struct W(crate::W<ADDRESS_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADDRESS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADDRESS_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADDRESS_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `address` reader - Controls the current device's USB address. Should be written after a SET_ADDRESS request is received. Automatically resets back to zero on a USB reset."]
        pub type ADDRESS_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `address` writer - Controls the current device's USB address. Should be written after a SET_ADDRESS request is received. Automatically resets back to zero on a USB reset."]
        pub type ADDRESS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, ADDRESS_SPEC, u8, u8, 8, O>;
        impl R {
            #[doc = "Bits 0:7 - Controls the current device's USB address. Should be written after a SET_ADDRESS request is received. Automatically resets back to zero on a USB reset."]
            #[inline(always)]
            pub fn address(&self) -> ADDRESS_R {
                ADDRESS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Controls the current device's USB address. Should be written after a SET_ADDRESS request is received. Automatically resets back to zero on a USB reset."]
            #[inline(always)]
            #[must_use]
            pub fn address(&mut self) -> ADDRESS_W<0> {
                ADDRESS_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_setup address register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [address](index.html) module"]
        pub struct ADDRESS_SPEC;
        impl crate::RegisterSpec for ADDRESS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [address::R](R) reader structure"]
        impl crate::Readable for ADDRESS_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [address::W](W) writer structure"]
        impl crate::Writable for ADDRESS_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets address to value 0"]
        impl crate::Resettable for ADDRESS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_status (r) register accessor: an alias for `Reg<EV_STATUS_SPEC>`"]
    pub type EV_STATUS = crate::Reg<ev_status::EV_STATUS_SPEC>;
    #[doc = "usb0_setup ev_status register"]
    pub mod ev_status {
        #[doc = "Register `ev_status` reader"]
        pub struct R(crate::R<EV_STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `status` reader - usb0_setup status register field"]
        pub type STATUS_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - usb0_setup status register field"]
            #[inline(always)]
            pub fn status(&self) -> STATUS_R {
                STATUS_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "usb0_setup ev_status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_status](index.html) module"]
        pub struct EV_STATUS_SPEC;
        impl crate::RegisterSpec for EV_STATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_status::R](R) reader structure"]
        impl crate::Readable for EV_STATUS_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets ev_status to value 0"]
        impl crate::Resettable for EV_STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_pending (rw) register accessor: an alias for `Reg<EV_PENDING_SPEC>`"]
    pub type EV_PENDING = crate::Reg<ev_pending::EV_PENDING_SPEC>;
    #[doc = "usb0_setup ev_pending register"]
    pub mod ev_pending {
        #[doc = "Register `ev_pending` reader"]
        pub struct R(crate::R<EV_PENDING_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_PENDING_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_PENDING_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_PENDING_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ev_pending` writer"]
        pub struct W(crate::W<EV_PENDING_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EV_PENDING_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EV_PENDING_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EV_PENDING_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `pending` reader - usb0_setup pending register field"]
        pub type PENDING_R = crate::BitReader<bool>;
        #[doc = "Field `pending` writer - usb0_setup pending register field"]
        pub type PENDING_W<'a, const O: u8> = crate::BitWriter<'a, u32, EV_PENDING_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - usb0_setup pending register field"]
            #[inline(always)]
            pub fn pending(&self) -> PENDING_R {
                PENDING_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - usb0_setup pending register field"]
            #[inline(always)]
            #[must_use]
            pub fn pending(&mut self) -> PENDING_W<0> {
                PENDING_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_setup ev_pending register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_pending](index.html) module"]
        pub struct EV_PENDING_SPEC;
        impl crate::RegisterSpec for EV_PENDING_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_pending::R](R) reader structure"]
        impl crate::Readable for EV_PENDING_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ev_pending::W](W) writer structure"]
        impl crate::Writable for EV_PENDING_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ev_pending to value 0"]
        impl crate::Resettable for EV_PENDING_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_enable (rw) register accessor: an alias for `Reg<EV_ENABLE_SPEC>`"]
    pub type EV_ENABLE = crate::Reg<ev_enable::EV_ENABLE_SPEC>;
    #[doc = "usb0_setup ev_enable register"]
    pub mod ev_enable {
        #[doc = "Register `ev_enable` reader"]
        pub struct R(crate::R<EV_ENABLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_ENABLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_ENABLE_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ev_enable` writer"]
        pub struct W(crate::W<EV_ENABLE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EV_ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EV_ENABLE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EV_ENABLE_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `enable` reader - usb0_setup enable register field"]
        pub type ENABLE_R = crate::BitReader<bool>;
        #[doc = "Field `enable` writer - usb0_setup enable register field"]
        pub type ENABLE_W<'a, const O: u8> = crate::BitWriter<'a, u32, EV_ENABLE_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - usb0_setup enable register field"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - usb0_setup enable register field"]
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<0> {
                ENABLE_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_setup ev_enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_enable](index.html) module"]
        pub struct EV_ENABLE_SPEC;
        impl crate::RegisterSpec for EV_ENABLE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_enable::R](R) reader structure"]
        impl crate::Readable for EV_ENABLE_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ev_enable::W](W) writer structure"]
        impl crate::Writable for EV_ENABLE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ev_enable to value 0"]
        impl crate::Resettable for EV_ENABLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "USB0_EP0_IN"]
pub struct USB0_EP0_IN {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB0_EP0_IN {}
impl USB0_EP0_IN {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep0_in::RegisterBlock = 0x5000_0080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep0_in::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USB0_EP0_IN {
    type Target = usb0_ep0_in::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB0_EP0_IN {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB0_EP0_IN").finish()
    }
}
#[doc = "USB0_EP0_IN"]
pub mod usb0_ep0_in {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - usb0_ep0_in data register"]
        pub data: DATA,
        #[doc = "0x04 - usb0_ep0_in epno register"]
        pub epno: EPNO,
        #[doc = "0x08 - usb0_ep0_in reset register"]
        pub reset: RESET,
        #[doc = "0x0c - usb0_ep0_in stall register"]
        pub stall: STALL,
        #[doc = "0x10 - usb0_ep0_in idle register"]
        pub idle: IDLE,
        #[doc = "0x14 - usb0_ep0_in have register"]
        pub have: HAVE,
        #[doc = "0x18 - usb0_ep0_in pend register"]
        pub pend: PEND,
        #[doc = "0x1c - usb0_ep0_in pid register"]
        pub pid: PID,
        #[doc = "0x20 - usb0_ep0_in ev_status register"]
        pub ev_status: EV_STATUS,
        #[doc = "0x24 - usb0_ep0_in ev_pending register"]
        pub ev_pending: EV_PENDING,
        #[doc = "0x28 - usb0_ep0_in ev_enable register"]
        pub ev_enable: EV_ENABLE,
    }
    #[doc = "data (w) register accessor: an alias for `Reg<DATA_SPEC>`"]
    pub type DATA = crate::Reg<data::DATA_SPEC>;
    #[doc = "usb0_ep0_in data register"]
    pub mod data {
        #[doc = "Register `data` writer"]
        pub struct W(crate::W<DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `data` writer - Write-only register. Each write enqueues a byte to be transmitted; gradually building a single packet to be transmitted. This queue should only ever contain a single packet; it is the software's responsibility to handle breaking requests down into packets."]
        pub type DATA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, DATA_SPEC, u8, u8, 8, O>;
        impl W {
            #[doc = "Bits 0:7 - Write-only register. Each write enqueues a byte to be transmitted; gradually building a single packet to be transmitted. This queue should only ever contain a single packet; it is the software's responsibility to handle breaking requests down into packets."]
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DATA_W<0> {
                DATA_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_in data register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
        pub struct DATA_SPEC;
        impl crate::RegisterSpec for DATA_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
        impl crate::Writable for DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets data to value 0"]
        impl crate::Resettable for DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "epno (rw) register accessor: an alias for `Reg<EPNO_SPEC>`"]
    pub type EPNO = crate::Reg<epno::EPNO_SPEC>;
    #[doc = "usb0_ep0_in epno register"]
    pub mod epno {
        #[doc = "Register `epno` reader"]
        pub struct R(crate::R<EPNO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EPNO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EPNO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EPNO_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `epno` writer"]
        pub struct W(crate::W<EPNO_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EPNO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EPNO_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EPNO_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `epno` reader - Contains the endpoint the enqueued packet is to be transmitted on. Writing this register marks the relevant packet as ready to transmit; and thus should only be written after a full packet has been written into the FIFO. If no data has been placed into the DATA FIFO, a zero-length packet is generated. Note that any IN requests that do not match the endpoint number are automatically NAK'd."]
        pub type EPNO_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `epno` writer - Contains the endpoint the enqueued packet is to be transmitted on. Writing this register marks the relevant packet as ready to transmit; and thus should only be written after a full packet has been written into the FIFO. If no data has been placed into the DATA FIFO, a zero-length packet is generated. Note that any IN requests that do not match the endpoint number are automatically NAK'd."]
        pub type EPNO_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EPNO_SPEC, u8, u8, 4, O>;
        impl R {
            #[doc = "Bits 0:3 - Contains the endpoint the enqueued packet is to be transmitted on. Writing this register marks the relevant packet as ready to transmit; and thus should only be written after a full packet has been written into the FIFO. If no data has been placed into the DATA FIFO, a zero-length packet is generated. Note that any IN requests that do not match the endpoint number are automatically NAK'd."]
            #[inline(always)]
            pub fn epno(&self) -> EPNO_R {
                EPNO_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Contains the endpoint the enqueued packet is to be transmitted on. Writing this register marks the relevant packet as ready to transmit; and thus should only be written after a full packet has been written into the FIFO. If no data has been placed into the DATA FIFO, a zero-length packet is generated. Note that any IN requests that do not match the endpoint number are automatically NAK'd."]
            #[inline(always)]
            #[must_use]
            pub fn epno(&mut self) -> EPNO_W<0> {
                EPNO_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_in epno register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [epno](index.html) module"]
        pub struct EPNO_SPEC;
        impl crate::RegisterSpec for EPNO_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [epno::R](R) reader structure"]
        impl crate::Readable for EPNO_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [epno::W](W) writer structure"]
        impl crate::Writable for EPNO_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets epno to value 0"]
        impl crate::Resettable for EPNO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "reset (w) register accessor: an alias for `Reg<RESET_SPEC>`"]
    pub type RESET = crate::Reg<reset::RESET_SPEC>;
    #[doc = "usb0_ep0_in reset register"]
    pub mod reset {
        #[doc = "Register `reset` writer"]
        pub struct W(crate::W<RESET_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RESET_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RESET_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RESET_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `reset` writer - A write to this register clears the FIFO without transmitting."]
        pub type RESET_W<'a, const O: u8> = crate::BitWriter<'a, u32, RESET_SPEC, bool, O>;
        impl W {
            #[doc = "Bit 0 - A write to this register clears the FIFO without transmitting."]
            #[inline(always)]
            #[must_use]
            pub fn reset(&mut self) -> RESET_W<0> {
                RESET_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_in reset register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reset](index.html) module"]
        pub struct RESET_SPEC;
        impl crate::RegisterSpec for RESET_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [reset::W](W) writer structure"]
        impl crate::Writable for RESET_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets reset to value 0"]
        impl crate::Resettable for RESET_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "stall (rw) register accessor: an alias for `Reg<STALL_SPEC>`"]
    pub type STALL = crate::Reg<stall::STALL_SPEC>;
    #[doc = "usb0_ep0_in stall register"]
    pub mod stall {
        #[doc = "Register `stall` reader"]
        pub struct R(crate::R<STALL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STALL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STALL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STALL_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `stall` writer"]
        pub struct W(crate::W<STALL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STALL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STALL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STALL_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `stall` reader - When this register contains '1', any IN tokens targeting `epno` will be responded to with a STALL token, rather than DATA or a NAK. For EP0, this register will automatically be cleared when a new SETUP token is received."]
        pub type STALL_R = crate::BitReader<bool>;
        #[doc = "Field `stall` writer - When this register contains '1', any IN tokens targeting `epno` will be responded to with a STALL token, rather than DATA or a NAK. For EP0, this register will automatically be cleared when a new SETUP token is received."]
        pub type STALL_W<'a, const O: u8> = crate::BitWriter<'a, u32, STALL_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - When this register contains '1', any IN tokens targeting `epno` will be responded to with a STALL token, rather than DATA or a NAK. For EP0, this register will automatically be cleared when a new SETUP token is received."]
            #[inline(always)]
            pub fn stall(&self) -> STALL_R {
                STALL_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - When this register contains '1', any IN tokens targeting `epno` will be responded to with a STALL token, rather than DATA or a NAK. For EP0, this register will automatically be cleared when a new SETUP token is received."]
            #[inline(always)]
            #[must_use]
            pub fn stall(&mut self) -> STALL_W<0> {
                STALL_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_in stall register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [stall](index.html) module"]
        pub struct STALL_SPEC;
        impl crate::RegisterSpec for STALL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [stall::R](R) reader structure"]
        impl crate::Readable for STALL_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [stall::W](W) writer structure"]
        impl crate::Writable for STALL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets stall to value 0"]
        impl crate::Resettable for STALL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "idle (r) register accessor: an alias for `Reg<IDLE_SPEC>`"]
    pub type IDLE = crate::Reg<idle::IDLE_SPEC>;
    #[doc = "usb0_ep0_in idle register"]
    pub mod idle {
        #[doc = "Register `idle` reader"]
        pub struct R(crate::R<IDLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IDLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IDLE_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `idle` reader - This value is `1` if no packet is actively being transmitted."]
        pub type IDLE_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - This value is `1` if no packet is actively being transmitted."]
            #[inline(always)]
            pub fn idle(&self) -> IDLE_R {
                IDLE_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "usb0_ep0_in idle register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [idle](index.html) module"]
        pub struct IDLE_SPEC;
        impl crate::RegisterSpec for IDLE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [idle::R](R) reader structure"]
        impl crate::Readable for IDLE_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets idle to value 0"]
        impl crate::Resettable for IDLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "have (r) register accessor: an alias for `Reg<HAVE_SPEC>`"]
    pub type HAVE = crate::Reg<have::HAVE_SPEC>;
    #[doc = "usb0_ep0_in have register"]
    pub mod have {
        #[doc = "Register `have` reader"]
        pub struct R(crate::R<HAVE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<HAVE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<HAVE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<HAVE_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `have` reader - This value is `1` if data is present in the transmit FIFO."]
        pub type HAVE_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - This value is `1` if data is present in the transmit FIFO."]
            #[inline(always)]
            pub fn have(&self) -> HAVE_R {
                HAVE_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "usb0_ep0_in have register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [have](index.html) module"]
        pub struct HAVE_SPEC;
        impl crate::RegisterSpec for HAVE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [have::R](R) reader structure"]
        impl crate::Readable for HAVE_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets have to value 0"]
        impl crate::Resettable for HAVE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "pend (r) register accessor: an alias for `Reg<PEND_SPEC>`"]
    pub type PEND = crate::Reg<pend::PEND_SPEC>;
    #[doc = "usb0_ep0_in pend register"]
    pub mod pend {
        #[doc = "Register `pend` reader"]
        pub struct R(crate::R<PEND_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PEND_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PEND_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PEND_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `pend` reader - `1` iff an interrupt is pending"]
        pub type PEND_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - `1` iff an interrupt is pending"]
            #[inline(always)]
            pub fn pend(&self) -> PEND_R {
                PEND_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "usb0_ep0_in pend register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pend](index.html) module"]
        pub struct PEND_SPEC;
        impl crate::RegisterSpec for PEND_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [pend::R](R) reader structure"]
        impl crate::Readable for PEND_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets pend to value 0"]
        impl crate::Resettable for PEND_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "pid (rw) register accessor: an alias for `Reg<PID_SPEC>`"]
    pub type PID = crate::Reg<pid::PID_SPEC>;
    #[doc = "usb0_ep0_in pid register"]
    pub mod pid {
        #[doc = "Register `pid` reader"]
        pub struct R(crate::R<PID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PID_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `pid` writer"]
        pub struct W(crate::W<PID_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PID_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PID_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `pid` reader - Contains the current PID toggle bit for the given endpoint."]
        pub type PID_R = crate::BitReader<bool>;
        #[doc = "Field `pid` writer - Contains the current PID toggle bit for the given endpoint."]
        pub type PID_W<'a, const O: u8> = crate::BitWriter<'a, u32, PID_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - Contains the current PID toggle bit for the given endpoint."]
            #[inline(always)]
            pub fn pid(&self) -> PID_R {
                PID_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Contains the current PID toggle bit for the given endpoint."]
            #[inline(always)]
            #[must_use]
            pub fn pid(&mut self) -> PID_W<0> {
                PID_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_in pid register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid](index.html) module"]
        pub struct PID_SPEC;
        impl crate::RegisterSpec for PID_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [pid::R](R) reader structure"]
        impl crate::Readable for PID_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [pid::W](W) writer structure"]
        impl crate::Writable for PID_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets pid to value 0"]
        impl crate::Resettable for PID_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_status (r) register accessor: an alias for `Reg<EV_STATUS_SPEC>`"]
    pub type EV_STATUS = crate::Reg<ev_status::EV_STATUS_SPEC>;
    #[doc = "usb0_ep0_in ev_status register"]
    pub mod ev_status {
        #[doc = "Register `ev_status` reader"]
        pub struct R(crate::R<EV_STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `status` reader - usb0_ep0_in status register field"]
        pub type STATUS_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - usb0_ep0_in status register field"]
            #[inline(always)]
            pub fn status(&self) -> STATUS_R {
                STATUS_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "usb0_ep0_in ev_status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_status](index.html) module"]
        pub struct EV_STATUS_SPEC;
        impl crate::RegisterSpec for EV_STATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_status::R](R) reader structure"]
        impl crate::Readable for EV_STATUS_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets ev_status to value 0"]
        impl crate::Resettable for EV_STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_pending (rw) register accessor: an alias for `Reg<EV_PENDING_SPEC>`"]
    pub type EV_PENDING = crate::Reg<ev_pending::EV_PENDING_SPEC>;
    #[doc = "usb0_ep0_in ev_pending register"]
    pub mod ev_pending {
        #[doc = "Register `ev_pending` reader"]
        pub struct R(crate::R<EV_PENDING_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_PENDING_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_PENDING_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_PENDING_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ev_pending` writer"]
        pub struct W(crate::W<EV_PENDING_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EV_PENDING_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EV_PENDING_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EV_PENDING_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `pending` reader - usb0_ep0_in pending register field"]
        pub type PENDING_R = crate::BitReader<bool>;
        #[doc = "Field `pending` writer - usb0_ep0_in pending register field"]
        pub type PENDING_W<'a, const O: u8> = crate::BitWriter<'a, u32, EV_PENDING_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - usb0_ep0_in pending register field"]
            #[inline(always)]
            pub fn pending(&self) -> PENDING_R {
                PENDING_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - usb0_ep0_in pending register field"]
            #[inline(always)]
            #[must_use]
            pub fn pending(&mut self) -> PENDING_W<0> {
                PENDING_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_in ev_pending register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_pending](index.html) module"]
        pub struct EV_PENDING_SPEC;
        impl crate::RegisterSpec for EV_PENDING_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_pending::R](R) reader structure"]
        impl crate::Readable for EV_PENDING_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ev_pending::W](W) writer structure"]
        impl crate::Writable for EV_PENDING_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ev_pending to value 0"]
        impl crate::Resettable for EV_PENDING_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_enable (rw) register accessor: an alias for `Reg<EV_ENABLE_SPEC>`"]
    pub type EV_ENABLE = crate::Reg<ev_enable::EV_ENABLE_SPEC>;
    #[doc = "usb0_ep0_in ev_enable register"]
    pub mod ev_enable {
        #[doc = "Register `ev_enable` reader"]
        pub struct R(crate::R<EV_ENABLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_ENABLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_ENABLE_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ev_enable` writer"]
        pub struct W(crate::W<EV_ENABLE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EV_ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EV_ENABLE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EV_ENABLE_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `enable` reader - usb0_ep0_in enable register field"]
        pub type ENABLE_R = crate::BitReader<bool>;
        #[doc = "Field `enable` writer - usb0_ep0_in enable register field"]
        pub type ENABLE_W<'a, const O: u8> = crate::BitWriter<'a, u32, EV_ENABLE_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - usb0_ep0_in enable register field"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - usb0_ep0_in enable register field"]
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<0> {
                ENABLE_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_in ev_enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_enable](index.html) module"]
        pub struct EV_ENABLE_SPEC;
        impl crate::RegisterSpec for EV_ENABLE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_enable::R](R) reader structure"]
        impl crate::Readable for EV_ENABLE_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ev_enable::W](W) writer structure"]
        impl crate::Writable for EV_ENABLE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ev_enable to value 0"]
        impl crate::Resettable for EV_ENABLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "USB0_EP0_OUT"]
pub struct USB0_EP0_OUT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB0_EP0_OUT {}
impl USB0_EP0_OUT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep0_out::RegisterBlock = 0x5000_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep0_out::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USB0_EP0_OUT {
    type Target = usb0_ep0_out::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB0_EP0_OUT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB0_EP0_OUT").finish()
    }
}
#[doc = "USB0_EP0_OUT"]
pub mod usb0_ep0_out {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - usb0_ep0_out data register"]
        pub data: DATA,
        #[doc = "0x04 - usb0_ep0_out data_ep register"]
        pub data_ep: DATA_EP,
        #[doc = "0x08 - usb0_ep0_out reset register"]
        pub reset: RESET,
        #[doc = "0x0c - usb0_ep0_out epno register"]
        pub epno: EPNO,
        #[doc = "0x10 - usb0_ep0_out enable register"]
        pub enable: ENABLE,
        #[doc = "0x14 - usb0_ep0_out prime register"]
        pub prime: PRIME,
        #[doc = "0x18 - usb0_ep0_out stall register"]
        pub stall: STALL,
        #[doc = "0x1c - usb0_ep0_out have register"]
        pub have: HAVE,
        #[doc = "0x20 - usb0_ep0_out pend register"]
        pub pend: PEND,
        #[doc = "0x24 - usb0_ep0_out address register"]
        pub address: ADDRESS,
        #[doc = "0x28 - usb0_ep0_out pid register"]
        pub pid: PID,
        _reserved11: [u8; 0x14],
        #[doc = "0x40 - usb0_ep0_out ev_status register"]
        pub ev_status: EV_STATUS,
        #[doc = "0x44 - usb0_ep0_out ev_pending register"]
        pub ev_pending: EV_PENDING,
        #[doc = "0x48 - usb0_ep0_out ev_enable register"]
        pub ev_enable: EV_ENABLE,
    }
    #[doc = "data (r) register accessor: an alias for `Reg<DATA_SPEC>`"]
    pub type DATA = crate::Reg<data::DATA_SPEC>;
    #[doc = "usb0_ep0_out data register"]
    pub mod data {
        #[doc = "Register `data` reader"]
        pub struct R(crate::R<DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `data` reader - A FIFO that returns the bytes from the most recently captured OUT transaction. Reading a byte from this register advances the FIFO."]
        pub type DATA_R = crate::FieldReader<u8, u8>;
        impl R {
            #[doc = "Bits 0:7 - A FIFO that returns the bytes from the most recently captured OUT transaction. Reading a byte from this register advances the FIFO."]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xff) as u8)
            }
        }
        #[doc = "usb0_ep0_out data register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
        pub struct DATA_SPEC;
        impl crate::RegisterSpec for DATA_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [data::R](R) reader structure"]
        impl crate::Readable for DATA_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets data to value 0"]
        impl crate::Resettable for DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "data_ep (r) register accessor: an alias for `Reg<DATA_EP_SPEC>`"]
    pub type DATA_EP = crate::Reg<data_ep::DATA_EP_SPEC>;
    #[doc = "usb0_ep0_out data_ep register"]
    pub mod data_ep {
        #[doc = "Register `data_ep` reader"]
        pub struct R(crate::R<DATA_EP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATA_EP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATA_EP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATA_EP_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `data_ep` reader - Register that contains the endpoint number associated with the data in the FIFO -- that is, the endpoint number on which the relevant data was received."]
        pub type DATA_EP_R = crate::FieldReader<u8, u8>;
        impl R {
            #[doc = "Bits 0:3 - Register that contains the endpoint number associated with the data in the FIFO -- that is, the endpoint number on which the relevant data was received."]
            #[inline(always)]
            pub fn data_ep(&self) -> DATA_EP_R {
                DATA_EP_R::new((self.bits & 0x0f) as u8)
            }
        }
        #[doc = "usb0_ep0_out data_ep register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_ep](index.html) module"]
        pub struct DATA_EP_SPEC;
        impl crate::RegisterSpec for DATA_EP_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [data_ep::R](R) reader structure"]
        impl crate::Readable for DATA_EP_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets data_ep to value 0"]
        impl crate::Resettable for DATA_EP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "reset (w) register accessor: an alias for `Reg<RESET_SPEC>`"]
    pub type RESET = crate::Reg<reset::RESET_SPEC>;
    #[doc = "usb0_ep0_out reset register"]
    pub mod reset {
        #[doc = "Register `reset` writer"]
        pub struct W(crate::W<RESET_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RESET_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RESET_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RESET_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `reset` writer - Local reset for the OUT handler; clears the out FIFO."]
        pub type RESET_W<'a, const O: u8> = crate::BitWriter<'a, u32, RESET_SPEC, bool, O>;
        impl W {
            #[doc = "Bit 0 - Local reset for the OUT handler; clears the out FIFO."]
            #[inline(always)]
            #[must_use]
            pub fn reset(&mut self) -> RESET_W<0> {
                RESET_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_out reset register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reset](index.html) module"]
        pub struct RESET_SPEC;
        impl crate::RegisterSpec for RESET_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [reset::W](W) writer structure"]
        impl crate::Writable for RESET_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets reset to value 0"]
        impl crate::Resettable for RESET_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "epno (rw) register accessor: an alias for `Reg<EPNO_SPEC>`"]
    pub type EPNO = crate::Reg<epno::EPNO_SPEC>;
    #[doc = "usb0_ep0_out epno register"]
    pub mod epno {
        #[doc = "Register `epno` reader"]
        pub struct R(crate::R<EPNO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EPNO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EPNO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EPNO_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `epno` writer"]
        pub struct W(crate::W<EPNO_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EPNO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EPNO_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EPNO_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `epno` reader - Selects the endpoint number to prime. This interface only allows priming a single endpoint at once-- that is, only one endpoint can be ready to receive data at a time. See the `enable` bit for usage."]
        pub type EPNO_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `epno` writer - Selects the endpoint number to prime. This interface only allows priming a single endpoint at once-- that is, only one endpoint can be ready to receive data at a time. See the `enable` bit for usage."]
        pub type EPNO_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EPNO_SPEC, u8, u8, 4, O>;
        impl R {
            #[doc = "Bits 0:3 - Selects the endpoint number to prime. This interface only allows priming a single endpoint at once-- that is, only one endpoint can be ready to receive data at a time. See the `enable` bit for usage."]
            #[inline(always)]
            pub fn epno(&self) -> EPNO_R {
                EPNO_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Selects the endpoint number to prime. This interface only allows priming a single endpoint at once-- that is, only one endpoint can be ready to receive data at a time. See the `enable` bit for usage."]
            #[inline(always)]
            #[must_use]
            pub fn epno(&mut self) -> EPNO_W<0> {
                EPNO_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_out epno register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [epno](index.html) module"]
        pub struct EPNO_SPEC;
        impl crate::RegisterSpec for EPNO_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [epno::R](R) reader structure"]
        impl crate::Readable for EPNO_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [epno::W](W) writer structure"]
        impl crate::Writable for EPNO_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets epno to value 0"]
        impl crate::Resettable for EPNO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "enable (rw) register accessor: an alias for `Reg<ENABLE_SPEC>`"]
    pub type ENABLE = crate::Reg<enable::ENABLE_SPEC>;
    #[doc = "usb0_ep0_out enable register"]
    pub mod enable {
        #[doc = "Register `enable` reader"]
        pub struct R(crate::R<ENABLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ENABLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ENABLE_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `enable` writer"]
        pub struct W(crate::W<ENABLE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ENABLE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ENABLE_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `enable` reader - Controls whether any data can be received on any primed OUT endpoint. This bit is automatically cleared on receive in order to give the controller time to read data from the FIFO. It must be re-enabled once the FIFO has been emptied."]
        pub type ENABLE_R = crate::BitReader<bool>;
        #[doc = "Field `enable` writer - Controls whether any data can be received on any primed OUT endpoint. This bit is automatically cleared on receive in order to give the controller time to read data from the FIFO. It must be re-enabled once the FIFO has been emptied."]
        pub type ENABLE_W<'a, const O: u8> = crate::BitWriter<'a, u32, ENABLE_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - Controls whether any data can be received on any primed OUT endpoint. This bit is automatically cleared on receive in order to give the controller time to read data from the FIFO. It must be re-enabled once the FIFO has been emptied."]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Controls whether any data can be received on any primed OUT endpoint. This bit is automatically cleared on receive in order to give the controller time to read data from the FIFO. It must be re-enabled once the FIFO has been emptied."]
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<0> {
                ENABLE_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_out enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [enable](index.html) module"]
        pub struct ENABLE_SPEC;
        impl crate::RegisterSpec for ENABLE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [enable::R](R) reader structure"]
        impl crate::Readable for ENABLE_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [enable::W](W) writer structure"]
        impl crate::Writable for ENABLE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets enable to value 0"]
        impl crate::Resettable for ENABLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "prime (w) register accessor: an alias for `Reg<PRIME_SPEC>`"]
    pub type PRIME = crate::Reg<prime::PRIME_SPEC>;
    #[doc = "usb0_ep0_out prime register"]
    pub mod prime {
        #[doc = "Register `prime` writer"]
        pub struct W(crate::W<PRIME_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PRIME_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PRIME_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PRIME_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `prime` writer - Controls \"priming\" an out endpoint. To receive data on any endpoint, the CPU must first select the endpoint with the `epno` register; and then write a '1' into the prime and enable register. This prepares our FIFO to receive data; and the next OUT transaction will be captured into the FIFO. When a transaction is complete, the `enable` bit is reset; the `prime` is not. This effectively means that `enable` controls receiving on _any_ of the primed endpoints; while `prime` can be used to build a collection of endpoints willing to participate in receipt. Only one transaction / data packet is captured per `enable` write; repeated enabling is necessary to capture multiple packets."]
        pub type PRIME_W<'a, const O: u8> = crate::BitWriter<'a, u32, PRIME_SPEC, bool, O>;
        impl W {
            #[doc = "Bit 0 - Controls \"priming\" an out endpoint. To receive data on any endpoint, the CPU must first select the endpoint with the `epno` register; and then write a '1' into the prime and enable register. This prepares our FIFO to receive data; and the next OUT transaction will be captured into the FIFO. When a transaction is complete, the `enable` bit is reset; the `prime` is not. This effectively means that `enable` controls receiving on _any_ of the primed endpoints; while `prime` can be used to build a collection of endpoints willing to participate in receipt. Only one transaction / data packet is captured per `enable` write; repeated enabling is necessary to capture multiple packets."]
            #[inline(always)]
            #[must_use]
            pub fn prime(&mut self) -> PRIME_W<0> {
                PRIME_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_out prime register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prime](index.html) module"]
        pub struct PRIME_SPEC;
        impl crate::RegisterSpec for PRIME_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [prime::W](W) writer structure"]
        impl crate::Writable for PRIME_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets prime to value 0"]
        impl crate::Resettable for PRIME_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "stall (rw) register accessor: an alias for `Reg<STALL_SPEC>`"]
    pub type STALL = crate::Reg<stall::STALL_SPEC>;
    #[doc = "usb0_ep0_out stall register"]
    pub mod stall {
        #[doc = "Register `stall` reader"]
        pub struct R(crate::R<STALL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STALL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STALL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STALL_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `stall` writer"]
        pub struct W(crate::W<STALL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STALL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STALL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STALL_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `stall` reader - Controls STALL'ing the active endpoint. Setting or clearing this bit will set or clear STALL on the provided endpoint. Endpoint STALLs persist even after `epno` is changed; so multiple endpoints can be stalled at once by writing their respective endpoint numbers into `epno` register and then setting their `stall` bits."]
        pub type STALL_R = crate::BitReader<bool>;
        #[doc = "Field `stall` writer - Controls STALL'ing the active endpoint. Setting or clearing this bit will set or clear STALL on the provided endpoint. Endpoint STALLs persist even after `epno` is changed; so multiple endpoints can be stalled at once by writing their respective endpoint numbers into `epno` register and then setting their `stall` bits."]
        pub type STALL_W<'a, const O: u8> = crate::BitWriter<'a, u32, STALL_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - Controls STALL'ing the active endpoint. Setting or clearing this bit will set or clear STALL on the provided endpoint. Endpoint STALLs persist even after `epno` is changed; so multiple endpoints can be stalled at once by writing their respective endpoint numbers into `epno` register and then setting their `stall` bits."]
            #[inline(always)]
            pub fn stall(&self) -> STALL_R {
                STALL_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Controls STALL'ing the active endpoint. Setting or clearing this bit will set or clear STALL on the provided endpoint. Endpoint STALLs persist even after `epno` is changed; so multiple endpoints can be stalled at once by writing their respective endpoint numbers into `epno` register and then setting their `stall` bits."]
            #[inline(always)]
            #[must_use]
            pub fn stall(&mut self) -> STALL_W<0> {
                STALL_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_out stall register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [stall](index.html) module"]
        pub struct STALL_SPEC;
        impl crate::RegisterSpec for STALL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [stall::R](R) reader structure"]
        impl crate::Readable for STALL_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [stall::W](W) writer structure"]
        impl crate::Writable for STALL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets stall to value 0"]
        impl crate::Resettable for STALL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "have (r) register accessor: an alias for `Reg<HAVE_SPEC>`"]
    pub type HAVE = crate::Reg<have::HAVE_SPEC>;
    #[doc = "usb0_ep0_out have register"]
    pub mod have {
        #[doc = "Register `have` reader"]
        pub struct R(crate::R<HAVE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<HAVE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<HAVE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<HAVE_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `have` reader - `1` iff data is available in the FIFO."]
        pub type HAVE_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - `1` iff data is available in the FIFO."]
            #[inline(always)]
            pub fn have(&self) -> HAVE_R {
                HAVE_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "usb0_ep0_out have register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [have](index.html) module"]
        pub struct HAVE_SPEC;
        impl crate::RegisterSpec for HAVE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [have::R](R) reader structure"]
        impl crate::Readable for HAVE_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets have to value 0"]
        impl crate::Resettable for HAVE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "pend (r) register accessor: an alias for `Reg<PEND_SPEC>`"]
    pub type PEND = crate::Reg<pend::PEND_SPEC>;
    #[doc = "usb0_ep0_out pend register"]
    pub mod pend {
        #[doc = "Register `pend` reader"]
        pub struct R(crate::R<PEND_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PEND_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PEND_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PEND_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `pend` reader - `1` iff an interrupt is pending"]
        pub type PEND_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - `1` iff an interrupt is pending"]
            #[inline(always)]
            pub fn pend(&self) -> PEND_R {
                PEND_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "usb0_ep0_out pend register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pend](index.html) module"]
        pub struct PEND_SPEC;
        impl crate::RegisterSpec for PEND_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [pend::R](R) reader structure"]
        impl crate::Readable for PEND_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets pend to value 0"]
        impl crate::Resettable for PEND_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "address (rw) register accessor: an alias for `Reg<ADDRESS_SPEC>`"]
    pub type ADDRESS = crate::Reg<address::ADDRESS_SPEC>;
    #[doc = "usb0_ep0_out address register"]
    pub mod address {
        #[doc = "Register `address` reader"]
        pub struct R(crate::R<ADDRESS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADDRESS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADDRESS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADDRESS_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `address` writer"]
        pub struct W(crate::W<ADDRESS_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADDRESS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADDRESS_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADDRESS_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `address` reader - Controls the current device's USB address. Should be written after a SET_ADDRESS request is received. Automatically resets back to zero on a USB reset."]
        pub type ADDRESS_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `address` writer - Controls the current device's USB address. Should be written after a SET_ADDRESS request is received. Automatically resets back to zero on a USB reset."]
        pub type ADDRESS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, ADDRESS_SPEC, u8, u8, 8, O>;
        impl R {
            #[doc = "Bits 0:7 - Controls the current device's USB address. Should be written after a SET_ADDRESS request is received. Automatically resets back to zero on a USB reset."]
            #[inline(always)]
            pub fn address(&self) -> ADDRESS_R {
                ADDRESS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Controls the current device's USB address. Should be written after a SET_ADDRESS request is received. Automatically resets back to zero on a USB reset."]
            #[inline(always)]
            #[must_use]
            pub fn address(&mut self) -> ADDRESS_W<0> {
                ADDRESS_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_out address register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [address](index.html) module"]
        pub struct ADDRESS_SPEC;
        impl crate::RegisterSpec for ADDRESS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [address::R](R) reader structure"]
        impl crate::Readable for ADDRESS_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [address::W](W) writer structure"]
        impl crate::Writable for ADDRESS_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets address to value 0"]
        impl crate::Resettable for ADDRESS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "pid (rw) register accessor: an alias for `Reg<PID_SPEC>`"]
    pub type PID = crate::Reg<pid::PID_SPEC>;
    #[doc = "usb0_ep0_out pid register"]
    pub mod pid {
        #[doc = "Register `pid` reader"]
        pub struct R(crate::R<PID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PID_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `pid` writer"]
        pub struct W(crate::W<PID_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PID_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PID_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `pid` reader - Contains the current PID toggle bit for the given endpoint."]
        pub type PID_R = crate::BitReader<bool>;
        #[doc = "Field `pid` writer - Contains the current PID toggle bit for the given endpoint."]
        pub type PID_W<'a, const O: u8> = crate::BitWriter<'a, u32, PID_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - Contains the current PID toggle bit for the given endpoint."]
            #[inline(always)]
            pub fn pid(&self) -> PID_R {
                PID_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Contains the current PID toggle bit for the given endpoint."]
            #[inline(always)]
            #[must_use]
            pub fn pid(&mut self) -> PID_W<0> {
                PID_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_out pid register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid](index.html) module"]
        pub struct PID_SPEC;
        impl crate::RegisterSpec for PID_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [pid::R](R) reader structure"]
        impl crate::Readable for PID_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [pid::W](W) writer structure"]
        impl crate::Writable for PID_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets pid to value 0"]
        impl crate::Resettable for PID_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_status (r) register accessor: an alias for `Reg<EV_STATUS_SPEC>`"]
    pub type EV_STATUS = crate::Reg<ev_status::EV_STATUS_SPEC>;
    #[doc = "usb0_ep0_out ev_status register"]
    pub mod ev_status {
        #[doc = "Register `ev_status` reader"]
        pub struct R(crate::R<EV_STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `status` reader - usb0_ep0_out status register field"]
        pub type STATUS_R = crate::BitReader<bool>;
        impl R {
            #[doc = "Bit 0 - usb0_ep0_out status register field"]
            #[inline(always)]
            pub fn status(&self) -> STATUS_R {
                STATUS_R::new((self.bits & 1) != 0)
            }
        }
        #[doc = "usb0_ep0_out ev_status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_status](index.html) module"]
        pub struct EV_STATUS_SPEC;
        impl crate::RegisterSpec for EV_STATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_status::R](R) reader structure"]
        impl crate::Readable for EV_STATUS_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets ev_status to value 0"]
        impl crate::Resettable for EV_STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_pending (rw) register accessor: an alias for `Reg<EV_PENDING_SPEC>`"]
    pub type EV_PENDING = crate::Reg<ev_pending::EV_PENDING_SPEC>;
    #[doc = "usb0_ep0_out ev_pending register"]
    pub mod ev_pending {
        #[doc = "Register `ev_pending` reader"]
        pub struct R(crate::R<EV_PENDING_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_PENDING_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_PENDING_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_PENDING_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ev_pending` writer"]
        pub struct W(crate::W<EV_PENDING_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EV_PENDING_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EV_PENDING_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EV_PENDING_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `pending` reader - usb0_ep0_out pending register field"]
        pub type PENDING_R = crate::BitReader<bool>;
        #[doc = "Field `pending` writer - usb0_ep0_out pending register field"]
        pub type PENDING_W<'a, const O: u8> = crate::BitWriter<'a, u32, EV_PENDING_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - usb0_ep0_out pending register field"]
            #[inline(always)]
            pub fn pending(&self) -> PENDING_R {
                PENDING_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - usb0_ep0_out pending register field"]
            #[inline(always)]
            #[must_use]
            pub fn pending(&mut self) -> PENDING_W<0> {
                PENDING_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_out ev_pending register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_pending](index.html) module"]
        pub struct EV_PENDING_SPEC;
        impl crate::RegisterSpec for EV_PENDING_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_pending::R](R) reader structure"]
        impl crate::Readable for EV_PENDING_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ev_pending::W](W) writer structure"]
        impl crate::Writable for EV_PENDING_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ev_pending to value 0"]
        impl crate::Resettable for EV_PENDING_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ev_enable (rw) register accessor: an alias for `Reg<EV_ENABLE_SPEC>`"]
    pub type EV_ENABLE = crate::Reg<ev_enable::EV_ENABLE_SPEC>;
    #[doc = "usb0_ep0_out ev_enable register"]
    pub mod ev_enable {
        #[doc = "Register `ev_enable` reader"]
        pub struct R(crate::R<EV_ENABLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EV_ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EV_ENABLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EV_ENABLE_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ev_enable` writer"]
        pub struct W(crate::W<EV_ENABLE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EV_ENABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EV_ENABLE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EV_ENABLE_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `enable` reader - usb0_ep0_out enable register field"]
        pub type ENABLE_R = crate::BitReader<bool>;
        #[doc = "Field `enable` writer - usb0_ep0_out enable register field"]
        pub type ENABLE_W<'a, const O: u8> = crate::BitWriter<'a, u32, EV_ENABLE_SPEC, bool, O>;
        impl R {
            #[doc = "Bit 0 - usb0_ep0_out enable register field"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - usb0_ep0_out enable register field"]
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<0> {
                ENABLE_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "usb0_ep0_out ev_enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_enable](index.html) module"]
        pub struct EV_ENABLE_SPEC;
        impl crate::RegisterSpec for EV_ENABLE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ev_enable::R](R) reader structure"]
        impl crate::Readable for EV_ENABLE_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ev_enable::W](W) writer structure"]
        impl crate::Writable for EV_ENABLE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ev_enable to value 0"]
        impl crate::Resettable for EV_ENABLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "LEDS"]
pub struct LEDS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LEDS {}
impl LEDS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const leds::RegisterBlock = 0x5000_0180 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const leds::RegisterBlock {
        Self::PTR
    }
}
impl Deref for LEDS {
    type Target = leds::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LEDS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LEDS").finish()
    }
}
#[doc = "LEDS"]
pub mod leds {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - leds output register"]
        pub output: OUTPUT,
    }
    #[doc = "output (w) register accessor: an alias for `Reg<OUTPUT_SPEC>`"]
    pub type OUTPUT = crate::Reg<output::OUTPUT_SPEC>;
    #[doc = "leds output register"]
    pub mod output {
        #[doc = "Register `output` writer"]
        pub struct W(crate::W<OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<OUTPUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `output` writer - leds output register field"]
        pub type OUTPUT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, OUTPUT_SPEC, u8, u8, 6, O>;
        impl W {
            #[doc = "Bits 0:5 - leds output register field"]
            #[inline(always)]
            #[must_use]
            pub fn output(&mut self) -> OUTPUT_W<0> {
                OUTPUT_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "leds output register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [output](index.html) module"]
        pub struct OUTPUT_SPEC;
        impl crate::RegisterSpec for OUTPUT_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [output::W](W) writer structure"]
        impl crate::Writable for OUTPUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets output to value 0"]
        impl crate::Resettable for OUTPUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "TIMER"]
    pub TIMER: TIMER,
    #[doc = "UART"]
    pub UART: UART,
    #[doc = "USB0"]
    pub USB0: USB0,
    #[doc = "USB0_SETUP"]
    pub USB0_SETUP: USB0_SETUP,
    #[doc = "USB0_EP0_IN"]
    pub USB0_EP0_IN: USB0_EP0_IN,
    #[doc = "USB0_EP0_OUT"]
    pub USB0_EP0_OUT: USB0_EP0_OUT,
    #[doc = "LEDS"]
    pub LEDS: LEDS,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            TIMER: TIMER {
                _marker: PhantomData,
            },
            UART: UART {
                _marker: PhantomData,
            },
            USB0: USB0 {
                _marker: PhantomData,
            },
            USB0_SETUP: USB0_SETUP {
                _marker: PhantomData,
            },
            USB0_EP0_IN: USB0_EP0_IN {
                _marker: PhantomData,
            },
            USB0_EP0_OUT: USB0_EP0_OUT {
                _marker: PhantomData,
            },
            LEDS: LEDS {
                _marker: PhantomData,
            },
        }
    }
}
