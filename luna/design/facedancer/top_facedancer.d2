facedancer_git: facedancer.git

# - examples/ -----------------------------------------------------------------

facedancer_git.examples_rubber_ducky: examples/rubber_ducky.py
facedancer_git.examples_rubber_ducky.code: |python
    import asyncio
    import logging

    from facedancer import main
    from facedancer.devices.keyboard     import USBKeyboardDevice
    from facedancer.classes.hid.keyboard import KeyboardModifiers

    device = USBKeyboardDevice()

    async def type_letters():
        logging.info("Beginning message typing demo...")

        # Type ls.
        await asyncio.sleep(5)
        await device.type_letters('l', 's', '\n')

        # Echo hi.
        await asyncio.sleep(2)
        await device.type_string("echo hi, user\n")

        # Finally, try to pop calc, just for fun.
        logging.info("Bonus: trying to pop calc.")
        await device.type_string('r', modifiers=KeyboardModifiers.MOD_LEFT_META)
        await asyncio.sleep(0.5)
        await device.type_string('calc\n')


        logging.info("Typing complete. Idly handling USB requests.")

    main(device, type_letters())
|

facedancer_git.examples_rubber_ducky.code -> facedancer_git.devices_init.default_main: main(device, type_letters())


# - facedancer/devices/ -------------------------------------------------------

facedancer_git.devices_init: facedancer/devices/__init__.py
facedancer_git.devices_init: {
    default_main: |python
        def default_main(device_or_type, *coroutines):
            """ Simple, default main for FaceDancer emulation.

            Parameters:
                device_type -- The USBDevice type to emulate.
            """

            # Instantiate the relevant device, and connect it to our host.
            parser = argparse.ArgumentParser(description=f"Emulation frontend for {device_or_type.name}(s).")
            parser.add_argument('--print-only', action='store_true', help="Prints information about the device without emulating.")
            parser.add_argument('--suggest', action='store_true', help="Prints suggested code additions after device emualtion is complete.")
            parser.add_argument('-v', '--verbose', help="Controls verbosity. 0=silent, 3=default, 5=spammy", default=3)
            args = parser.parse_args()

            if sys.stdout.isatty():
                log_format = LOG_FORMAT_COLOR
            else:
                log_format = LOG_FORMAT_PLAIN

            # Set up our logging output.
            python_loglevel = 50 - (int(args.verbose) * 10)
            logging.basicConfig(level=python_loglevel, format=log_format)

            if inspect.isclass(device_or_type):
                device = device_or_type()
            else:
                device = device_or_type

            if args.print_only:
                pprint.pprint(device)
                sys.exit(0)

            # Run the relevant code, along with any added coroutines.
            device.emulate(*coroutines)

            if args.suggest:
                device.print_suggested_additions()
    |
}

facedancer_git.devices_init.default_main -> facedancer_git.future_device.USBBaseDevice.emulate: device.emulate(*coroutines)

# - facedancer/future/ --------------------------------------------------------

facedancer_git.future_device: facedancer/future/device.py
facedancer_git.future_device.USBBaseDevice: {
    style: {
        fill: lightgreen
    }
    emulate: |python
        def emulate(self, *coroutines: Iterable[asyncio.coroutine]):
            """ Convenience method that runs a full method in a blocking manner.
            Performs connect, run, and then disconnect.

            Parameters:
                *coroutines -- any asyncio coroutines to be executed concurrently
                               with our emulation
            """

            self.connect()

            try:
                self.run_with(*coroutines)
            except KeyboardInterrupt:
                pass
            finally:
                self.disconnect()

    |
    run_with: |python
        def run_with(self, *coroutines: Iterable[asyncio.coroutine]):
            """
            Runs the actual device emulation synchronously; running any provided
            coroutines simultaneously.
            """

            async def inner():
                await asyncio.gather(self.run(), *coroutines)

            asyncio.run(inner())
    |
    run: |python
        async def run(self):
            """ Runs the actual device emulation. """

            # Sanity check to avoid common issues.
            if len(self.configurations) == 0:
                logging.error("No configurations defined on the emulated device! "
                        "Did you forget @use_inner_classes_automatically?")

            if self.backend is None:
                self.connect()

            # Constantly service any events that need to be performed.
            while True:
                self.backend.service_irqs()
                await asyncio.sleep(0)
    |

    emulate -> run_with: self.run_with(*coroutines)
    run_with -> run: await asyncio.gather(self.run(), *coroutines)
}

facedancer_git.future_device.USBBaseDevice.run -> facedancer_git.backends_moondancer.service_irqs: self.backend.service_irqs()



# - facedancer/backends/ ------------------------------------------------------

facedancer_git.backends_moondancer: facedancer/backends/moondancer.py:MoondancerApp
# facedancer_git.backends_moondancer.MoondancerApp: {
#     shape: class
#     __init__(self, device=None, verbose=0, quirks=None)
#     init_commands(self): pass
#     get_version(): NotImplementedError
#     ack_status_stage(self, direction=HOST_TO_DEVICE, endpoint_number=0, blocking=False)
# }

facedancer_git.backends_moondancer: {
    __init__: |python
        def __init__(self, device=None, verbose=0, quirks=None):
            """
            Sets up a new GreatFET-backed Facedancer (GreatDancer) application.
            device: The GreatFET device that will act as our GreatDancer.
            verbose: The verbosity level of the given application.
            """

            import greatfet

            if device is None:
                device = greatfet.GreatFET()

            self.device = device

            self.device.comms.get_exclusive_access()

            FacedancerApp.__init__(self, device, verbose)
            self.connected_device = None

            # Grab the raw API object from the GreatFET object.
            # This has the low-level RPCs used for raw USB control.
            self.api = self.device.apis.greatdancer

            # Initialize a dictionary that will store the last setup
            # whether each endpoint is currently stalled.
            self.endpoint_stalled = {}
            for i in range(self.SUPPORTED_ENDPOINTS):
                self.endpoint_stalled[i] = False

            # Assume a max packet size of 64 until configured otherwise.
            self.max_ep0_packet_size = 64

            # Start off by assuming we're not waiting for an OUT control transfer's
            # data stage.  # See _handle_setup_complete_on_endpoint for details.
            self.pending_control_request = None

            # Store a reference to the device's active configuration,
            # which we'll use to know which endpoints we'll need to check
            # for data transfer readiness.
            self.configuration = None

            #
            # Store our list of quirks to handle.
            #
            if quirks:
                self.quirks = quirks
            else:
                self.quirks = []
    |
    service_irqs: |python
        def service_irqs(self):
            """
            Core routine of the Facedancer execution/event loop. Continuously monitors the
            GreatDancer's execution status, and reacts as events occur.
            """

            status = self._fetch_irq_status()

            # Other bits that may be of interest:
            # D_SRI = start of frame received
            # D_PCI = port change detect (switched between low, full, high speed state)
            # D_SLI = device controller suspend
            # D_UEI = USB error; completion of transaction caused error, see usb1_isr in firmware
            # D_NAKI = both the tx/rx NAK bit and corresponding endpoint NAK enable are set

            if status & self.USBSTS_D_UI:
                self._handle_setup_events()
                self._handle_transfer_events()

            if status & self.USBSTS_D_URI:
                self._bus_reset()

            if status & self.USBSTS_D_NAKI:
                self._handle_nak_events()
    |
    service_irqs -> _fetch_irq_status: self._fetch_irq_status()
    service_irqs -> _handle_setup_events: self._handle_setup_events()
    service_irqs -> _handle_transfer_events: self._handle_transfer_events()
    service_irqs -> _bus_reset: self._bus_reset()
    service_irqs -> _handle_nak_events: self._handle_nak_events()
    _fetch_irq_status: |python
        def _fetch_irq_status(self):
            """
            Fetch the USB controller's pending-IRQ bitmask, which indicates
            which interrupts need to be serviced.

            returns: A raw integer bitmap.
            """
            return self.api.get_status(self.GET_USBSTS)
    |
    _handle_setup_events: |python
        def _handle_setup_events(self):
            """
            Handles any outstanding setup events on the USB controller.
            """

            # Determine if we have setup packets on any of our endpoints.
            status = self._fetch_setup_status()

            # If we don't, abort.
            if not status:
                return

            # Otherwise, figure out which endpoints have outstanding setup events,
            # and handle them.
            for i in range(self.SUPPORTED_ENDPOINTS):
                if status & (1 << i):
                    self._handle_setup_event_on_endpoint(i)
    |
    _handle_setup_events -> _handle_setup_event_on_endpoint: self._handle_setup_event_on_endpoint(i)
    _handle_setup_event_on_endpoint: |python
        def _handle_setup_event_on_endpoint(self, endpoint_number):
            """
            Handles a known outstanding setup event on a given endpoint.

            endpoint_number: The endpoint number for which a setup event should be serviced.
            """

            # HACK: to maintain API compatibility with the existing facedancer API,
            # we need to know if a stall happens at any point during our handler.
            self.endpoint_stalled[endpoint_number] = False

            # Read the data from the SETUP stage...
            data    = bytearray(self.api.read_setup(endpoint_number))
            request = self.connected_device.create_request(data)

            # If this is an OUT request, handle the data stage,
            # and add it to the request.
            is_out   = request.get_direction() == self.HOST_TO_DEVICE
            has_data = (request.length > 0)

            # Special case: if this is an OUT request with a data stage, we won't
            # handle the request until the data stage has been completed. Instead,
            # we'll stash away the data received in the setup stage, prime the
            # endpoint for the data stage, and then wait for the data stage to
            # complete, triggering a corresponding code path in
            # in _handle_transfer_complete_on_endpoint.
            if is_out and has_data:
                self._prime_out_endpoint(endpoint_number)
                self.pending_control_request = request
                return

            self.connected_device.handle_request(request)

            if not is_out and not self.endpoint_stalled[endpoint_number]:
                self.ack_status_stage(direction=self.DEVICE_TO_HOST)
    |
    _handle_transfer_events: |python
    def _handle_transfer_events(self):
        """
        Handles any outstanding setup events on the USB controller.
        """

        # Determine if we have ready packets on any of our endpoints.
        status = self._fetch_transfer_status()

        # If we don't, abort.
        if not status:
            return

        # Figure out which endpoints have recently completed transfers,
        # and clean up any transactions on those endpoints. It's important
        # that this be done /before/ the _handle_transfer_complete... section
        # below, as those can generate further events which will need the freed
        # transfer descriptors.
        # [Note that it's safe to clean up the transfer descriptors before reading,
        #  here-- the GreatFET's USB controller has transparently moved any data
        #  from OUT transactions into a holding buffer for us. Nice of it!]
        for i in range(self.SUPPORTED_ENDPOINTS):
            if status & (1 << i):
                self._clean_up_transfers_for_endpoint(i, self.HOST_TO_DEVICE)

            if status & (1 << (i + 16)):
                self._clean_up_transfers_for_endpoint(i, self.DEVICE_TO_HOST)

        # Now that we've cleaned up all relevant transfer descriptors, trigger
        # any events that should occur due to the completed transaction.
        for i in range(self.SUPPORTED_ENDPOINTS):
            if status & (1 << i):
                self._handle_transfer_complete_on_endpoint(i, self.HOST_TO_DEVICE)

            if status & (1 << (i + 16)):
                self._handle_transfer_complete_on_endpoint(i, self.DEVICE_TO_HOST)


        # Finally, after completing all of the above, we may now have idle
        # (unprimed) endpoints. For OUT endpoints, we'll need to re-prime them
        # so we're ready for receipt; for IN endpoints, we'll want to give the
        # emulated device a chance to provide new data.
        self._handle_transfer_readiness()
    |
    _bus_reset: |python
        def _bus_reset(self):
            """
            Triggers the GreatDancer to perform its side of a bus reset.
            """

            logging.debug("Host issued bus reset.")

            if self.connected_device:
                self.connected_device.handle_bus_reset()
            else:
                self.api.bus_reset()
    |
    _handle_nak_events: |python
        def _handle_nak_events(self):
            """
            Handles an event in which the GreatDancer has NAK'd an IN token.
            """

            # If we haven't been configured yet, we can't have any
            # endpoints other than the control endpoint, and we don't need to
            # handle any NAKs.
            if not self.configuration:
                return

            # Fetch the endpoint status.
            status = self._fetch_endpoint_nak_status()

            # Iterate over each usable endpoint.
            for interface in self.configuration.get_interfaces():
                for endpoint in interface.get_endpoints():

                    # If the endpoint has NAK'd, issued the relevant callback.
                    if self._has_issued_nak(status, endpoint.number, endpoint.direction):
                        self.connected_device.handle_nak(endpoint.number)
    |
}
facedancer_git.backends_moondancer.__init__ -- greatfet_git.host_greatfet.__init__: self.device = greatfet.GreatFET()
facedancer_git.backends_moondancer.__init__ -- libgreat_git.pygreat.GreatBoard.__init__: self.api = self.device.apis.greatdancer

facedancer_git.backends_moondancer._handle_setup_event_on_endpoint -> greatfet_git.firmware_greatfet_usb_classes_greatdancer: {
    label: self.api.read_setup(endpoint_number)
    style: {
        font-size: 24
        stroke-width: 5
        stroke: green
    }
}

# - libgreat.git/host/pygreat/board.py -------------------------------

libgreat_git: libgreat.git

libgreat_git.pygreat.GreatBoard: host/pygreat/board.py:GreatBoard
libgreat_git.pygreat.GreatBoard: {
    __init__: |python
        def __init__(self, **device_identifiers):
            """
            Instantiates a new connection to a libgreat device; by default connects
            to the first available board.

            Accepts the same arguments as pyusb's usb.find() method, allowing narrowing
            to a more specific board by serial number.

            FIXME: accept an identifier string or a comms_backend object instead of the
            array above
            """

            # By default, accept any device with the default vendor/product IDs.
            self.identifiers = self.populate_default_identifiers(device_identifiers)

            # For convenience, allow serial_number=None to be equivalent to not
            # providing a serial number: a board with any serial number will be
            # accepted.
            if 'serial_number' in self.identifiers and self.identifiers['serial_number'] is None:
                del self.identifiers['serial_number']

            # TODO: replace this with a comms_string
            # Create our backend connection to the device.
            self.comms = CommsBackend.from_device_uri(**self.identifiers)

            # Get an object that allows easy access to each of our APIs.
            self.apis = self.comms.generate_api_object()

            # TODO: optionally use the core API to discover other APIs

            # Final sanity check: if we don't handle this board ID, bail out!
            if self.HANDLED_BOARD_IDS and (self.board_id() not in self.HANDLED_BOARD_IDS):
                raise DeviceNotFoundError()
    |
}


# - greatfet.git/host/greatfet/greatfet.py ------------------------------------

greatfet_git: greatfet.git

greatfet_git.host_greatfet: greatfet.git/host/greatfet/greatfet.py
greatfet_git.host_greatfet: {
    __init__: |python
        def GreatFET(**board_identifiers):
            """
                    Attempts to create a new instance of GreatFET board (sub)class
                    most applicable to the given device. For example, if the attached
                    board is a GreatFET One, this will automatically create a
                    GreatFETOne object.

                    Accepts the same arguments as pyusb's usb.find() method, allowing narrowing
                    to a more specific GreatFET by e.g. serial number. Like usb.find(), providing
                    find_all will return a list of all found devices.

                    Throws a DeviceNotFoundError if no device is avaiable and find_all is not set.
            """

            if 'find_all' in board_identifiers and board_identifiers['find_all']:
                del board_identifiers['find_all']
                return GreatFETBoard.autodetect_all(**board_identifiers)
            else:
                return GreatFETBoard.autodetect(**board_identifiers)

    |
}


# - greatfet.git/firmware/greatfet_usb/classes/greatdancer.c ------------------

greatfet_git.firmware_greatfet_usb_classes_greatdancer: greatfet.git/firmware/greatfet_usb/classes/greatdancer.c
greatfet_git.firmware_greatfet_usb_classes_greatdancer: {
    read_setup: |c
        /**
         * Reads a setup packet from the GreatDancer port and relays it to the host.
         * The index parameter specifies which endpoint we should be reading from.
         *
         * Always transmits an 8-byte setup packet back to the host. If no setup packet
         * is waiting, the results of this vendor request are unspecified.
         */
        static int greatdancer_verb_read_setup(struct command_transaction *trans)
        {
            uint_fast8_t address;

            usb_setup_t *setup_data;
            usb_endpoint_t *target_endpoint;

            int endpoint_number = comms_argument_parse_uint8_t(trans);

            if (!comms_transaction_okay(trans)) {
                return EBADMSG;
            }

            // Figure out the endpoint we\'re reading setup data from...
            address = usb_endpoint_address(USB_TRANSFER_DIRECTION_OUT, endpoint_number);
            target_endpoint = usb_endpoint_from_address(address, &usb_peripherals[1]);

            if (!target_endpoint) {
                pr_error("greatdancer: trying to read a setup packet from an impossible endpoint %x!\n", address);
            }

            // ... and find its setup data.
            setup_data = (usb_setup_t *)usb_queue_head(target_endpoint->address, target_endpoint->device)->setup;

            // Validate that we got a sane pointer from the USB stack.
            if (!setup_data) {
                pr_error("greatdancer: internal error -- USB API passed us a NULL setup packet pointer!\n");
                return EFAULT;
            }

            // Reserve space for the target data...
            comms_response_add_raw(trans, setup_data, sizeof(*setup_data));

            // workaround for issue 344 (https://github.com/greatscottgadgets/greatfet/issues/344)
            usb_queue_flush_endpoint(target_endpoint->in);
            usb_queue_flush_endpoint(target_endpoint->out);

            // ... and mark that packet as handled.
            usb_clear_endpoint_setup_status(1 << endpoint_number, &usb_peripherals[1]);

            return 0;
        }
    |
}
